<?xml version="1.0" encoding="UTF-8"?><diffreport><diff><table border="0" cellpadding="1" cellspacing="0" width="100%"><tr><td><h3 class="ctxid">class:MemoryLayout [NONE]</h3></td></tr><tr><td><table border="0" cellpadding="5" cellspacing="1" bgcolor="black" width="100%"><tr valign="top"><td bgcolor="#FFFFFF" colspan="1"> <a start_ctx_id="class:MemoryLayout"/> <section class="class-description" id="class-description"><dl class="notes"> <dt>All Known Subinterfaces:  </dt><dd> <code><a href="GroupLayout.html" title="interface in java.lang.foreign">GroupLayout</a><sup><a href="GroupLayout.html#preview-java.lang.foreign.GroupLayout">PREVIEW</a></sup></code>, <code><a href="PaddingLayout.html" title="interface in java.lang.foreign">PaddingLayout</a><sup><a href="PaddingLayout.html#preview-java.lang.foreign.PaddingLayout">PREVIEW</a></sup></code>, <code><a href="SequenceLayout.html" title="interface in java.lang.foreign">SequenceLayout</a><sup><a href="SequenceLayout.html#preview-java.lang.foreign.SequenceLayout">PREVIEW</a></sup></code>, <code><a href="StructLayout.html" title="interface in java.lang.foreign">StructLayout</a><sup><a href="StructLayout.html#preview-java.lang.foreign.StructLayout">PREVIEW</a></sup></code>, <code><a href="UnionLayout.html" title="interface in java.lang.foreign">UnionLayout</a><sup><a href="UnionLayout.html#preview-java.lang.foreign.UnionLayout">PREVIEW</a></sup></code>, <code><a href="ValueLayout.html" title="interface in java.lang.foreign">ValueLayout</a><sup><a href="ValueLayout.html#preview-java.lang.foreign.ValueLayout">PREVIEW</a></sup></code>, <code><a href="ValueLayout.OfAddress.html" title="interface in java.lang.foreign">ValueLayout.OfAddress</a><sup><a href="ValueLayout.OfAddress.html#preview-java.lang.foreign.ValueLayout.OfAddress">PREVIEW</a></sup></code>, <code><a href="ValueLayout.OfBoolean.html" title="interface in java.lang.foreign">ValueLayout.OfBoolean</a><sup><a href="ValueLayout.OfBoolean.html#preview-java.lang.foreign.ValueLayout.OfBoolean">PREVIEW</a></sup></code>, <code><a href="ValueLayout.OfByte.html" title="interface in java.lang.foreign">ValueLayout.OfByte</a><sup><a href="ValueLayout.OfByte.html#preview-java.lang.foreign.ValueLayout.OfByte">PREVIEW</a></sup></code>, <code><a href="ValueLayout.OfChar.html" title="interface in java.lang.foreign">ValueLayout.OfChar</a><sup><a href="ValueLayout.OfChar.html#preview-java.lang.foreign.ValueLayout.OfChar">PREVIEW</a></sup></code>, <code><a href="ValueLayout.OfDouble.html" title="interface in java.lang.foreign">ValueLayout.OfDouble</a><sup><a href="ValueLayout.OfDouble.html#preview-java.lang.foreign.ValueLayout.OfDouble">PREVIEW</a></sup></code>, <code><a href="ValueLayout.OfFloat.html" title="interface in java.lang.foreign">ValueLayout.OfFloat</a><sup><a href="ValueLayout.OfFloat.html#preview-java.lang.foreign.ValueLayout.OfFloat">PREVIEW</a></sup></code>, <code><a href="ValueLayout.OfInt.html" title="interface in java.lang.foreign">ValueLayout.OfInt</a><sup><a href="ValueLayout.OfInt.html#preview-java.lang.foreign.ValueLayout.OfInt">PREVIEW</a></sup></code>, <code><a href="ValueLayout.OfLong.html" title="interface in java.lang.foreign">ValueLayout.OfLong</a><sup><a href="ValueLayout.OfLong.html#preview-java.lang.foreign.ValueLayout.OfLong">PREVIEW</a></sup></code>, <code><a href="ValueLayout.OfShort.html" title="interface in java.lang.foreign">ValueLayout.OfShort</a><sup><a href="ValueLayout.OfShort.html#preview-java.lang.foreign.ValueLayout.OfShort">PREVIEW</a></sup></code>               </dd> </dl> <hr/><div class="type-signature"> <span class="modifiers">public sealed interface    </span><span class="element-name type-name-label">MemoryLayout</span><span class="permits">permits <a href="SequenceLayout.html" title="interface in java.lang.foreign">SequenceLayout</a><sup><a href="SequenceLayout.html#preview-java.lang.foreign.SequenceLayout">PREVIEW</a></sup>, <a href="GroupLayout.html" title="interface in java.lang.foreign">GroupLayout</a><sup><a href="GroupLayout.html#preview-java.lang.foreign.GroupLayout">PREVIEW</a></sup>, <a href="PaddingLayout.html" title="interface in java.lang.foreign">PaddingLayout</a><sup><a href="PaddingLayout.html#preview-java.lang.foreign.PaddingLayout">PREVIEW</a></sup>, <a href="ValueLayout.html" title="interface in java.lang.foreign">ValueLayout</a><sup><a href="ValueLayout.html#preview-java.lang.foreign.ValueLayout">PREVIEW</a></sup>    </span> </div><div class="preview-block" id="preview-java.lang.foreign.MemoryLayout"> <span class="preview-label"><code>MemoryLayout</code> is a preview API of the Java platform.        </span><div class="preview-comment"> Programs can only use <code>MemoryLayout</code> when preview features are enabled.          </div><div class="preview-comment">Preview features may be removed in a future release, or upgraded to permanent features of the Java platform.                 </div> </div><div class="block"> A memory layout describes the contents of a memory segment. There are two leaves in the layout hierarchy, <em>value layouts </em>, which are used to represent values of given size and kind (see <a href="ValueLayout.html" title="interface in java.lang.foreign"><code>ValueLayout</code></a><sup><a href="ValueLayout.html#preview-java.lang.foreign.ValueLayout">PREVIEW</a></sup>) and <em>padding layouts </em> which are used, as the name suggests, to represent a portion of a memory segment whose contents should be ignored, and which are primarily present for alignment reasons (see <a href="#paddingLayout(long)"><code>paddingLayout(long)</code></a>). Some common value layout constants are defined in the <a href="ValueLayout.html" title="interface in java.lang.foreign"><code>ValueLayout</code></a><sup><a href="ValueLayout.html#preview-java.lang.foreign.ValueLayout">PREVIEW</a></sup> class.<p> More complex layouts can be derived from simpler ones: a <em>sequence layout </em> denotes a repetition of one or more element layout (see <a href="SequenceLayout.html" title="interface in java.lang.foreign"><code>SequenceLayout</code></a><sup><a href="SequenceLayout.html#preview-java.lang.foreign.SequenceLayout">PREVIEW</a></sup>); a <em>group layout </em> denotes an aggregation of (typically) heterogeneous member layouts (see <a href="GroupLayout.html" title="interface in java.lang.foreign"><code>GroupLayout</code></a><sup><a href="GroupLayout.html#preview-java.lang.foreign.GroupLayout">PREVIEW</a></sup>).                                  </p><p> Layouts can be optionally associated with a <em>name</em>. A layout name can be referred to when constructing <a href="MemoryLayout.html#layout-paths"><em>layout paths </em></a>.                  </p><p> Consider the following struct declaration in C:       </p><div class="snippet-container"> <button class="copy snippet-copy"><span data-copied="Copied!">Copy</span><img src="../../../../copy.svg" alt="Copy"/></button><pre class="snippet">
                                    <code class="language-c">typedef struct {
    char kind;
    int value;
} TaggedValues[5];
</code>
                                </pre> </div> The above declaration can be modelled using a layout object, as follows:<div class="snippet-container"> <button class="copy snippet-copy"><span data-copied="Copied!">Copy</span><img src="../../../../copy.svg" alt="Copy"/></button><pre class="snippet">
                                    <code class="language-java">SequenceLayout taggedValues = MemoryLayout.sequenceLayout(5,
    MemoryLayout.structLayout(
        ValueLayout.JAVA_BYTE.withName("kind"),
        MemoryLayout.paddingLayout(24),
        ValueLayout.JAVA_INT.withName("value")
    )
).withName("TaggedValues");
</code>
                                </pre> </div><h2 id="layout-align">Size, alignment and byte order    </h2> All layouts have a size; layout size for value and padding layouts is always explicitly denoted; this means that a layout description always has the same size in bits, regardless of the platform in which it is used. For derived layouts, the size is computed as follows:<ul><li> for a sequence layout <em>S</em> whose element layout is <em>E</em> and size is <em>L</em>, the size of <em>S</em> is that of <em>E</em>, multiplied by <em>L</em>                         </li><li> for a group layout <em>G</em> with member layouts <em>M1</em>, <em>M2</em>, ... <em>Mn</em> whose sizes are <em>S1</em>, <em>S2</em>, ... <em>Sn</em>, respectively, the size of <em>G</em> is either <em>S1 + S2 + ... + Sn      </em> or <em>max(S1, S2, ... Sn)   </em> depending on whether the group is a <em>struct</em> or an <em>union</em>, respectively                                         </li></ul><p> Furthermore, all layouts feature a <em>natural alignment </em> which can be inferred as follows:<ul><li> for a padding layout <em>L</em>, the natural alignment is 1, regardless of its size; that is, in the absence of an explicit alignment constraint, a padding layout should not affect the alignment constraint of the group layout it is nested into                                         </li><li> for a value layout <em>L</em> whose size is <em>N</em>, the natural alignment of <em>L</em> is <em>N</em>                </li><li> for a sequence layout <em>S</em> whose element layout is <em>E</em>, the natural alignment of <em>S</em> is that of <em>E</em>                   </li><li> for a group layout <em>G</em> with member layouts <em>M1</em>, <em>M2</em>, ... <em>Mn</em> whose alignments are <em>A1</em>, <em>A2</em>, ... <em>An</em>, respectively, the natural alignment of <em>G</em> is <em>max(A1, A2 ... An)   </em>                           </li></ul> A layout's natural alignment can be overridden if needed (see <a href="#withBitAlignment(long)"><code>withBitAlignment(long)</code></a>), which can be useful to describe hyper-aligned layouts.                               </p><p> All value layouts have an <em>explicit</em> byte order (see <a href="../../nio/ByteOrder.html" title="class in java.nio"><code>ByteOrder</code></a>) which is set when the layout is created.                  </p><h2 id="layout-paths">Layout paths </h2> A <em>layout path </em> originates from a <em>root</em> layout (typically a group or a sequence layout) and terminates at a layout nested within the root layout - this is the layout <em>selected</em> by the layout path. Layout paths are typically expressed as a sequence of one or more <a href="MemoryLayout.PathElement.html" title="interface in java.lang.foreign"><code>MemoryLayout.PathElement</code></a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup> instances.<p> Layout paths are for example useful in order to obtain <a href="#bitOffset(java.lang.foreign.MemoryLayout.PathElement...)">offsets</a> of arbitrarily nested layouts inside another layout, to quickly obtain a <a href="#varHandle(java.lang.foreign.MemoryLayout.PathElement...)">memory access handle  </a> corresponding to the selected layout, or to <a href="#select(java.lang.foreign.MemoryLayout.PathElement...)">select</a> an arbitrarily nested layout inside another layout.                                      </p><p> Such <em>layout paths </em> can be constructed programmatically using the methods in this class. For instance, given the <code>taggedValues</code> layout instance constructed as above, we can obtain the offset, in bits, of the member layout named <code>value</code> in the <em>first</em> sequence element, as follows:                                          </p><div class="snippet-container"> <button class="copy snippet-copy"><span data-copied="Copied!">Copy</span><img src="../../../../copy.svg" alt="Copy"/></button><pre class="snippet">
                                    <code class="language-java">long valueOffset = taggedValues.bitOffset(PathElement.sequenceElement(0),
                                          PathElement.groupElement("value")); // yields 32
</code>
                                </pre> </div> Similarly, we can select the member layout named <code>value</code>, as follows:<div class="snippet-container"> <button class="copy snippet-copy"><span data-copied="Copied!">Copy</span><img src="../../../../copy.svg" alt="Copy"/></button><pre class="snippet">
                                    <code class="language-java">MemoryLayout value = taggedValues.select(PathElement.sequenceElement(),
                                         PathElement.groupElement("value"));
</code>
                                </pre> </div> Layout paths can feature one or more <em>free dimensions </em>. For instance, a layout path traversing an unspecified sequence element (that is, where one of the path component was obtained with the <a href="MemoryLayout.PathElement.html#sequenceElement()"><code>MemoryLayout.PathElement.sequenceElement()</code></a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup> method) features an additional free dimension, which will have to be bound at runtime. This is important when obtaining a <a href="../invoke/MethodHandles.html#memorySegmentViewVarHandle(java.lang.foreign.ValueLayout)">memory segment view var handle    </a><sup><a href="../invoke/MethodHandles.html#preview-memorySegmentViewVarHandle(java.lang.foreign.ValueLayout)">PREVIEW</a></sup> from layouts, as in the following code:<div class="snippet-container"> <button class="copy snippet-copy"><span data-copied="Copied!">Copy</span><img src="../../../../copy.svg" alt="Copy"/></button><pre class="snippet">
                                    <code class="language-java">VarHandle valueHandle = taggedValues.varHandle(PathElement.sequenceElement(),
                                               PathElement.groupElement("value"));
</code>
                                </pre> </div> Since the layout path constructed in the above example features exactly one free dimension (as it doesn't specify <em>which</em> member layout named <code>value</code> should be selected from the enclosing sequence layout), it follows that the var handle <code>valueHandle</code> will feature an <em>additional</em><code>long</code> access coordinate.<p> A layout path with free dimensions can also be used to create an offset-computing method handle, using the <a href="#bitOffset(java.lang.foreign.MemoryLayout.PathElement...)"><code>bitOffset(PathElement...)</code></a> or <a href="#byteOffsetHandle(java.lang.foreign.MemoryLayout.PathElement...)"><code>byteOffsetHandle(PathElement...)</code></a> method. Again, free dimensions are translated into <code>long</code> parameters of the created method handle. The method handle can be used to compute the offsets of elements of a sequence at different indices, by supplying these indices when invoking the method handle. For instance:                                                                </p><div class="snippet-container"> <button class="copy snippet-copy"><span data-copied="Copied!">Copy</span><img src="../../../../copy.svg" alt="Copy"/></button><pre class="snippet">
                                    <code class="language-java">MethodHandle offsetHandle = taggedValues.byteOffsetHandle(PathElement.sequenceElement(),
                                                          PathElement.groupElement("kind"));
long offset1 = (long) offsetHandle.invokeExact(1L); // 8
long offset2 = (long) offsetHandle.invokeExact(2L); // 16
</code>
                                </pre> </div>                                                                                                                                                                                                                                                                                                        </div><dl class="notes"> <dt>Implementation Requirements: </dt><dd> Implementations of this interface are immutable, thread-safe and <a href="../../../../java.base/java/lang/doc-files/ValueBased.html">value-based</a>.         </dd> <dt>Sealed Class Hierarchy Graph:   </dt><dd> <a class="sealed-graph" href="MemoryLayout-sealed-graph.svg"><img style="vertical-align:top" alt="Sealed class hierarchy graph for MemoryLayout" src="MemoryLayout-sealed-graph.svg" height="100"/><span><img style="border: solid lightgray 1px; vertical-align:top" alt="Sealed class hierarchy graph for MemoryLayout" src="MemoryLayout-sealed-graph.svg"/></span></a> </dd> <dt>Since:</dt><dd>19</dd>   </dl>   </section> <a end_ctx_id="class:MemoryLayout"/>   </td></tr></table></td></tr></table><table border="0" cellpadding="1" cellspacing="0" width="100%"><tr><td><h3 class="ctxid">method:bitSize() [NONE]</h3></td></tr><tr><td><table border="0" cellpadding="5" cellspacing="1" bgcolor="black" width="100%"><tr valign="top"><td bgcolor="#FFFFFF" colspan="1"><li> <a start_ctx_id="method:bitSize()"/> <section class="detail" id="bitSize()"><h3>bitSize</h3><div class="member-signature"> <span class="return-type">long</span> <span class="element-name">bitSize</span>() </div><div class="block">Returns the layout size, in bits.     </div><dl class="notes"> <dt>Returns:</dt><dd>the layout size, in bits    </dd> </dl>  </section>  </li> <a end_ctx_id="method:bitSize()"/> </td></tr></table></td></tr></table><table border="0" cellpadding="1" cellspacing="0" width="100%"><tr><td><h3 class="ctxid">method:byteSize() [NONE]</h3></td></tr><tr><td><table border="0" cellpadding="5" cellspacing="1" bgcolor="black" width="100%"><tr valign="top"><td bgcolor="#FFFFFF" colspan="1"> <a start_ctx_id="method:byteSize()"/> <section class="detail" id="byteSize()"><h3>byteSize</h3><div class="member-signature"> <span class="return-type">long</span> <span class="element-name">byteSize</span>() </div><div class="block">Returns the layout size, in bytes.     </div><dl class="notes"> <dt>Returns:</dt><dd>the layout size, in bytes    </dd> <dt>Throws:</dt><dd> <code><a href="../UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if <code>bitSize()</code> is not a multiple of 8.          </dd>  </dl>  </section> <a end_ctx_id="method:byteSize()"/>   </td></tr></table></td></tr></table><table border="0" cellpadding="1" cellspacing="0" width="100%"><tr><td><h3 class="ctxid">method:name() [NONE]</h3></td></tr><tr><td><table border="0" cellpadding="5" cellspacing="1" bgcolor="black" width="100%"><tr valign="top"><td bgcolor="#FFFFFF" colspan="1"> <a start_ctx_id="method:name()"/> <section class="detail" id="name()"><h3>name</h3><div class="member-signature"> <span class="return-type"><a href="../../util/Optional.html" title="class in java.util">Optional</a>&lt;<a href="../String.html" title="class in java.lang">String</a>&gt;</span> <span class="element-name">name</span>() </div><div class="block">Returns the name (if any) associated with this layout.        </div><dl class="notes"> <dt>Returns:</dt><dd>the name (if any) associated with this layout       </dd> <dt>See Also: </dt><dd><ul class="tag-list"><li> <a href="#withName(java.lang.String)"><code>withName(String)</code></a> </li></ul></dd>  </dl>  </section> <a end_ctx_id="method:name()"/>   </td></tr></table></td></tr></table><table border="0" cellpadding="1" cellspacing="0" width="100%"><tr><td><h3 class="ctxid">method:withName(java.lang.String) [NONE]</h3></td></tr><tr><td><table border="0" cellpadding="5" cellspacing="1" bgcolor="black" width="100%"><tr valign="top"><td bgcolor="#FFFFFF" colspan="1"> <a start_ctx_id="method:withName(java.lang.String)"/> <section class="detail" id="withName(java.lang.String)"><h3>withName</h3><div class="member-signature"> <span class="return-type"><a href="MemoryLayout.html" title="interface in java.lang.foreign">MemoryLayout</a><sup><a href="#preview-java.lang.foreign.MemoryLayout">PREVIEW</a></sup></span> <span class="element-name">withName</span> <wbr/> <span class="parameters">(<a href="../String.html" title="class in java.lang">String</a> name)</span>   </div><div class="block">Returns a memory layout of the same type with the same size and alignment constraint as this layout, but with the specified name.                      </div><dl class="notes"> <dt>Parameters:</dt><dd> <code>name</code> - the layout name.     </dd> <dt>Returns:</dt><dd>a memory layout with the given name.      </dd> <dt>See Also: </dt><dd><ul class="tag-list"><li> <a href="#name()"><code>name()</code></a> </li></ul></dd>   </dl>  </section> <a end_ctx_id="method:withName(java.lang.String)"/>   </td></tr></table></td></tr></table><table border="0" cellpadding="1" cellspacing="0" width="100%"><tr><td><h3 class="ctxid">method:bitAlignment() [NONE]</h3></td></tr><tr><td><table border="0" cellpadding="5" cellspacing="1" bgcolor="black" width="100%"><tr valign="top"><td bgcolor="#FFFFFF" colspan="1"> <a start_ctx_id="method:bitAlignment()"/> <section class="detail" id="bitAlignment()"><h3>bitAlignment</h3><div class="member-signature"> <span class="return-type">long</span> <span class="element-name">bitAlignment</span>() </div><div class="block"> Returns the alignment constraint associated with this layout, expressed in bits. Layout alignment defines a power of two <code>A</code> which is the bit-wise alignment of the layout. If <code>A &lt;= 8  </code> then <code>A/8</code> is the number of bytes that must be aligned for any pointer that correctly points to this layout. Thus:<ul><li> <code>A=8</code> means unaligned (in the usual sense), which is common in packets.            </li><li> <code>A=64</code> means word aligned (on LP64), <code>A=32</code> int aligned, <code>A=16</code> short aligned, etc.             </li><li> <code>A=512</code> is the most strict alignment required by the x86/SV ABI (for AVX-512 data).              </li></ul> If no explicit alignment constraint was set on this layout (see <a href="#withBitAlignment(long)"><code>withBitAlignment(long)</code></a>), then this method returns the <a href="#layout-align">natural alignment </a> constraint (in bits) associated with this layout.                                                                           </div><dl class="notes"> <dt>Returns:</dt><dd>the layout alignment constraint, in bits.     </dd> </dl>  </section> <a end_ctx_id="method:bitAlignment()"/>   </td></tr></table></td></tr></table><table border="0" cellpadding="1" cellspacing="0" width="100%"><tr><td><h3 class="ctxid">method:byteAlignment() [CHANGED]</h3></td></tr><tr><td><table border="0" cellpadding="5" cellspacing="1" bgcolor="black" width="100%"><tr valign="top"><td bgcolor="#EEEEEE" colspan="2"> <a start_ctx_id="method:byteAlignment()"/> <section class="detail" id="byteAlignment()"><h3>byteAlignment</h3><div class="member-signature"> <span class="return-type"> <span class="modifiers" changeType="diff-removed-tag"><span class="diff-html-removed">default</span></span>long </span> <span class="element-name">byteAlignment</span>() </div><div class="block"> Returns the alignment constraint associated with this layout, expressed in bytes. Layout alignment defines a power of two <code>A</code> which is the byte-wise alignment of the layout, where <code>A</code> is the number of bytes that must be aligned for any pointer that correctly points to this layout. Thus:<ul><li> <code>A=1</code> means unaligned (in the usual sense), which is common in packets.            </li><li> <code>A=8</code> means word aligned (on LP64), <code>A=4</code> int aligned, <code>A=2</code> short aligned, etc.             </li><li> <code>A=64</code> is the most strict alignment required by the x86/SV ABI (for AVX-512 data).              </li></ul> If no explicit alignment constraint was set on this layout (see <a href="#withBitAlignment(long)"><code>withBitAlignment(long)</code></a>), then this method returns the <a href="#layout-align">natural alignment </a> constraint (in bytes) associated with this layout.                                                                         </div><dl class="notes"> <dt>Returns:</dt><dd>the layout alignment constraint, in bytes.     </dd> <dt>Throws:</dt><dd> <code><a href="../UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if <code>bitAlignment()</code> is not a multiple of 8.          </dd>  </dl>  </section> <a end_ctx_id="method:byteAlignment()"/>   </td></tr><tr valign="top"><td bgcolor="#CCCCCC" colspan="1"> <a start_ctx_id="method:byteAlignment()"/> <section class="detail" id="byteAlignment()"><h3>byteAlignment</h3><div class="member-signature"> <span class="modifiers" changeType="diff-removed-tag">default</span> <span class="return-type">long</span> <span class="element-name">byteAlignment</span>() </div><div class="block"> Returns the alignment constraint associated with this layout, expressed in bytes. Layout alignment defines a power of two <code>A</code> which is the byte-wise alignment of the layout, where <code>A</code> is the number of bytes that must be aligned for any pointer that correctly points to this layout. Thus:<ul><li> <code>A=1</code> means unaligned (in the usual sense), which is common in packets.            </li><li> <code>A=8</code> means word aligned (on LP64), <code>A=4</code> int aligned, <code>A=2</code> short aligned, etc.             </li><li> <code>A=64</code> is the most strict alignment required by the x86/SV ABI (for AVX-512 data).              </li></ul> If no explicit alignment constraint was set on this layout (see <a href="#withBitAlignment(long)"><code>withBitAlignment(long)</code></a>), then this method returns the <a href="#layout-align">natural alignment </a> constraint (in bytes) associated with this layout.                                                                         </div><dl class="notes"> <dt>Returns:</dt><dd>the layout alignment constraint, in bytes.     </dd> <dt>Throws:</dt><dd> <code><a href="../UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if <code>bitAlignment()</code> is not a multiple of 8.          </dd>  </dl>  </section> <a end_ctx_id="method:byteAlignment()"/>   </td><td bgcolor="#FFFFFF" colspan="1"> <a start_ctx_id="method:byteAlignment()"/> <section class="detail" id="byteAlignment()"><h3>byteAlignment</h3><div class="member-signature"> <span class="return-type">long</span> <span class="element-name">byteAlignment</span>() </div><div class="block"> Returns the alignment constraint associated with this layout, expressed in bytes. Layout alignment defines a power of two <code>A</code> which is the byte-wise alignment of the layout, where <code>A</code> is the number of bytes that must be aligned for any pointer that correctly points to this layout. Thus:<ul><li> <code>A=1</code> means unaligned (in the usual sense), which is common in packets.            </li><li> <code>A=8</code> means word aligned (on LP64), <code>A=4</code> int aligned, <code>A=2</code> short aligned, etc.             </li><li> <code>A=64</code> is the most strict alignment required by the x86/SV ABI (for AVX-512 data).              </li></ul> If no explicit alignment constraint was set on this layout (see <a href="#withBitAlignment(long)"><code>withBitAlignment(long)</code></a>), then this method returns the <a href="#layout-align">natural alignment </a> constraint (in bytes) associated with this layout.                                                                         </div><dl class="notes"> <dt>Returns:</dt><dd>the layout alignment constraint, in bytes.     </dd> <dt>Throws:</dt><dd> <code><a href="../UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if <code>bitAlignment()</code> is not a multiple of 8.          </dd>  </dl>  </section> <a end_ctx_id="method:byteAlignment()"/>   </td></tr></table></td></tr></table><table border="0" cellpadding="1" cellspacing="0" width="100%"><tr><td><h3 class="ctxid">method:withBitAlignment(long) [NONE]</h3></td></tr><tr><td><table border="0" cellpadding="5" cellspacing="1" bgcolor="black" width="100%"><tr valign="top"><td bgcolor="#FFFFFF" colspan="1"> <a start_ctx_id="method:withBitAlignment(long)"/> <section class="detail" id="withBitAlignment(long)"><h3>withBitAlignment</h3><div class="member-signature"> <span class="return-type"><a href="MemoryLayout.html" title="interface in java.lang.foreign">MemoryLayout</a><sup><a href="#preview-java.lang.foreign.MemoryLayout">PREVIEW</a></sup></span> <span class="element-name">withBitAlignment</span> <wbr/> <span class="parameters">(long bitAlignment)</span>   </div><div class="block">Returns a memory layout of the same type with the same size and name as this layout, but with the specified alignment constraint (in bits).                        </div><dl class="notes"> <dt>Parameters:</dt><dd> <code>bitAlignment</code> - the layout alignment constraint, expressed in bits.         </dd> <dt>Returns:</dt><dd>a memory layout with the given alignment constraint.       </dd> <dt>Throws:</dt><dd> <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if <code>bitAlignment</code> is not a power of two, or if it's less than 8.                </dd>   </dl>  </section> <a end_ctx_id="method:withBitAlignment(long)"/>   </td></tr></table></td></tr></table><table border="0" cellpadding="1" cellspacing="0" width="100%"><tr><td><h3 class="ctxid">method:bitOffset(java.lang.foreign.MemoryLayout.PathElement...) [CHANGED]</h3></td></tr><tr><td><table border="0" cellpadding="5" cellspacing="1" bgcolor="black" width="100%"><tr valign="top"><td bgcolor="#EEEEEE" colspan="2"> <a start_ctx_id="method:bitOffset(java.lang.foreign.MemoryLayout.PathElement...)"/> <section class="detail" id="bitOffset(java.lang.foreign.MemoryLayout.PathElement...)"><h3>bitOffset</h3><div class="member-signature"> <span class="modifiers">default</span> <span class="return-type">long</span> <span class="element-name">bitOffset</span> <wbr/> <span class="parameters">(<a href="MemoryLayout.PathElement.html" title="interface in java.lang.foreign">MemoryLayout.PathElement</a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>... elements)</span>   </div><div class="block">Computes the offset, in bits, of the layout selected by the given layout path, where the path is considered rooted in this layout.                      </div><dl class="notes"> <dt>Parameters:</dt><dd> <code>elements</code> - the layout path elements.      </dd> <dt>Returns:</dt><dd> The offset, in bits, of the layout selected by the layout path in <code>elements</code>.              </dd> <dt>Throws:</dt><dd> <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the layout path does not select any layout nested in this layout, or if the layout path contains one or more path elements that select multiple sequence element indices (see <a href="MemoryLayout.PathElement.html#sequenceElement()"><code>MemoryLayout.PathElement.sequenceElement()</code></a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup> and <a href="MemoryLayout.PathElement.html#sequenceElement(long,long)"><code>MemoryLayout.PathElement.sequenceElement(long, long) </code></a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>).                                    </dd><dd> <code><a href="../IllegalArgumentException.html" title="class in java.lang"><span class="diff-html-added">IllegalArgumentException</span></a></code> <span class="diff-html-added">-</span> <span class="diff-html-added">if</span> <span class="diff-html-added">the</span> <span class="diff-html-added">layout</span> <span class="diff-html-added">path</span> <span class="diff-html-added">contains</span> <span class="diff-html-added">one</span> <span class="diff-html-added">or</span> <span class="diff-html-added">more</span> <span class="diff-html-added">dereference</span> <span class="diff-html-added">path</span> <span class="diff-html-added">elements</span> <span class="diff-html-added">(see</span> <a href="MemoryLayout.PathElement.html#dereferenceElement()"><code><span class="diff-html-added">MemoryLayout.PathElement.dereferenceElement()</span></code></a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement"><span class="diff-html-added">PREVIEW</span></a></sup><span class="diff-html-added">).</span>               </dd><dd> <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - if either <code>elements == null  </code>, or if any of the elements in <code>elements</code> is <code>null</code>.               </dd>   </dl>  </section> <a end_ctx_id="method:bitOffset(java.lang.foreign.MemoryLayout.PathElement...)"/>   </td></tr><tr valign="top"><td bgcolor="#CCCCCC" colspan="1"> <a start_ctx_id="method:bitOffset(java.lang.foreign.MemoryLayout.PathElement...)"/> <section class="detail" id="bitOffset(java.lang.foreign.MemoryLayout.PathElement...)"><h3>bitOffset</h3><div class="member-signature"> <span class="modifiers">default</span> <span class="return-type">long</span> <span class="element-name">bitOffset</span> <wbr/> <span class="parameters">(<a href="MemoryLayout.PathElement.html" title="interface in java.lang.foreign">MemoryLayout.PathElement</a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>... elements)</span>   </div><div class="block">Computes the offset, in bits, of the layout selected by the given layout path, where the path is considered rooted in this layout.                      </div><dl class="notes"> <dt>Parameters:</dt><dd> <code>elements</code> - the layout path elements.      </dd> <dt>Returns:</dt><dd> The offset, in bits, of the layout selected by the layout path in <code>elements</code>.              </dd> <dt>Throws:</dt><dd> <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the layout path does not select any layout nested in this layout, or if the layout path contains one or more path elements that select multiple sequence element indices (see <a href="MemoryLayout.PathElement.html#sequenceElement()"><code>MemoryLayout.PathElement.sequenceElement()</code></a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup> and <a href="MemoryLayout.PathElement.html#sequenceElement(long,long)"><code>MemoryLayout.PathElement.sequenceElement(long, long) </code></a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>).                                    </dd><dd> <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - if either <code>elements == null  </code>, or if any of the elements in <code>elements</code> is <code>null</code>.               </dd>   </dl>  </section> <a end_ctx_id="method:bitOffset(java.lang.foreign.MemoryLayout.PathElement...)"/>   </td><td bgcolor="#FFFFFF" colspan="1"> <a start_ctx_id="method:bitOffset(java.lang.foreign.MemoryLayout.PathElement...)"/> <section class="detail" id="bitOffset(java.lang.foreign.MemoryLayout.PathElement...)"><h3>bitOffset</h3><div class="member-signature"> <span class="modifiers">default</span> <span class="return-type">long</span> <span class="element-name">bitOffset</span> <wbr/> <span class="parameters">(<a href="MemoryLayout.PathElement.html" title="interface in java.lang.foreign">MemoryLayout.PathElement</a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>... elements)</span>   </div><div class="block">Computes the offset, in bits, of the layout selected by the given layout path, where the path is considered rooted in this layout.                      </div><dl class="notes"> <dt>Parameters:</dt><dd> <code>elements</code> - the layout path elements.      </dd> <dt>Returns:</dt><dd> The offset, in bits, of the layout selected by the layout path in <code>elements</code>.              </dd> <dt>Throws:</dt><dd> <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the layout path does not select any layout nested in this layout, or if the layout path contains one or more path elements that select multiple sequence element indices (see <a href="MemoryLayout.PathElement.html#sequenceElement()"><code>MemoryLayout.PathElement.sequenceElement()</code></a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup> and <a href="MemoryLayout.PathElement.html#sequenceElement(long,long)"><code>MemoryLayout.PathElement.sequenceElement(long, long) </code></a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>).                                    </dd><dd> <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the layout path contains one or more dereference path elements (see <a href="MemoryLayout.PathElement.html#dereferenceElement()"><code>MemoryLayout.PathElement.dereferenceElement()</code></a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>).               </dd><dd> <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - if either <code>elements == null  </code>, or if any of the elements in <code>elements</code> is <code>null</code>.               </dd>   </dl>  </section> <a end_ctx_id="method:bitOffset(java.lang.foreign.MemoryLayout.PathElement...)"/>   </td></tr></table></td></tr></table><table border="0" cellpadding="1" cellspacing="0" width="100%"><tr><td><h3 class="ctxid">method:bitOffsetHandle(java.lang.foreign.MemoryLayout.PathElement...) [CHANGED]</h3></td></tr><tr><td><table border="0" cellpadding="5" cellspacing="1" bgcolor="black" width="100%"><tr valign="top"><td bgcolor="#EEEEEE" colspan="2"> <a start_ctx_id="method:bitOffsetHandle(java.lang.foreign.MemoryLayout.PathElement...)"/> <section class="detail" id="bitOffsetHandle(java.lang.foreign.MemoryLayout.PathElement...)"><h3>bitOffsetHandle</h3><div class="member-signature"> <span class="modifiers">default</span> <span class="return-type"><a href="../invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></span> <span class="element-name">bitOffsetHandle</span> <wbr/> <span class="parameters">(<a href="MemoryLayout.PathElement.html" title="interface in java.lang.foreign">MemoryLayout.PathElement</a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>... elements)</span>   </div><div class="block"> Creates a method handle that can be used to compute the offset, in bits, of the layout selected by the given layout path, where the path is considered rooted in this layout.<p> The returned method handle has a return type of <code>long</code>, and features as many <code>long</code> parameter types as there are free dimensions in the provided layout path (see <a href="MemoryLayout.PathElement.html#sequenceElement()"><code>MemoryLayout.PathElement.sequenceElement()</code></a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>), where the order of the parameters corresponds to the order of the path elements. The returned method handle can be used to compute a layout offset similar to <a href="#bitOffset(java.lang.foreign.MemoryLayout.PathElement...)"><code>bitOffset(PathElement...)</code></a>, but where some sequence indices are specified only when invoking the method handle.                                                                       </p><p>The final offset returned by the method handle is computed as follows:           </p><blockquote><pre>
                                                            <code>
 offset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)
 </code>
                                                        </pre></blockquote> where <code>x_1</code>, <code>x_2</code>, ... <code>x_n</code> are <em>dynamic</em> values provided as <code>long</code> arguments, whereas <code>c_1</code>, <code>c_2</code>, ... <code>c_m</code> are <em>static</em> offset constants and <code>s_0</code>, <code>s_1</code>, ... <code>s_n</code> are <em>static</em> stride constants which are derived from the layout path.                                                                     </div><dl class="notes"> <dt>Parameters:</dt><dd> <code>elements</code> - the layout path elements.      </dd> <dt>Returns:</dt><dd>a method handle that can be used to compute the bit offset of the layout element specified by the given layout path elements, when supplied with the missing sequence element indices.                              </dd> <dt>Throws:</dt><dd> <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the layout path contains one or more path elements that select multiple sequence element indices (see <a href="MemoryLayout.PathElement.html#sequenceElement(long,long)"><code>MemoryLayout.PathElement.sequenceElement(long, long) </code></a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>).                    </dd><dd> <code><a href="../IllegalArgumentException.html" title="class in java.lang"><span class="diff-html-added">IllegalArgumentException</span></a></code> <span class="diff-html-added">-</span> <span class="diff-html-added">if</span> <span class="diff-html-added">the</span> <span class="diff-html-added">layout</span> <span class="diff-html-added">path</span> <span class="diff-html-added">contains</span> <span class="diff-html-added">one</span> <span class="diff-html-added">or</span> <span class="diff-html-added">more</span> <span class="diff-html-added">dereference</span> <span class="diff-html-added">path</span> <span class="diff-html-added">elements</span> <span class="diff-html-added">(see</span> <a href="MemoryLayout.PathElement.html#dereferenceElement()"><code><span class="diff-html-added">MemoryLayout.PathElement.dereferenceElement()</span></code></a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement"><span class="diff-html-added">PREVIEW</span></a></sup><span class="diff-html-added">).</span>               </dd>   </dl>  </section> <a end_ctx_id="method:bitOffsetHandle(java.lang.foreign.MemoryLayout.PathElement...)"/>   </td></tr><tr valign="top"><td bgcolor="#CCCCCC" colspan="1"> <a start_ctx_id="method:bitOffsetHandle(java.lang.foreign.MemoryLayout.PathElement...)"/> <section class="detail" id="bitOffsetHandle(java.lang.foreign.MemoryLayout.PathElement...)"><h3>bitOffsetHandle</h3><div class="member-signature"> <span class="modifiers">default</span> <span class="return-type"><a href="../invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></span> <span class="element-name">bitOffsetHandle</span> <wbr/> <span class="parameters">(<a href="MemoryLayout.PathElement.html" title="interface in java.lang.foreign">MemoryLayout.PathElement</a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>... elements)</span>   </div><div class="block"> Creates a method handle that can be used to compute the offset, in bits, of the layout selected by the given layout path, where the path is considered rooted in this layout.<p> The returned method handle has a return type of <code>long</code>, and features as many <code>long</code> parameter types as there are free dimensions in the provided layout path (see <a href="MemoryLayout.PathElement.html#sequenceElement()"><code>MemoryLayout.PathElement.sequenceElement()</code></a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>), where the order of the parameters corresponds to the order of the path elements. The returned method handle can be used to compute a layout offset similar to <a href="#bitOffset(java.lang.foreign.MemoryLayout.PathElement...)"><code>bitOffset(PathElement...)</code></a>, but where some sequence indices are specified only when invoking the method handle.                                                                       </p><p>The final offset returned by the method handle is computed as follows:           </p><blockquote><pre>
                                                            <code>
 offset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)
 </code>
                                                        </pre></blockquote> where <code>x_1</code>, <code>x_2</code>, ... <code>x_n</code> are <em>dynamic</em> values provided as <code>long</code> arguments, whereas <code>c_1</code>, <code>c_2</code>, ... <code>c_m</code> are <em>static</em> offset constants and <code>s_0</code>, <code>s_1</code>, ... <code>s_n</code> are <em>static</em> stride constants which are derived from the layout path.                                                                     </div><dl class="notes"> <dt>Parameters:</dt><dd> <code>elements</code> - the layout path elements.      </dd> <dt>Returns:</dt><dd>a method handle that can be used to compute the bit offset of the layout element specified by the given layout path elements, when supplied with the missing sequence element indices.                              </dd> <dt>Throws:</dt><dd> <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the layout path contains one or more path elements that select multiple sequence element indices (see <a href="MemoryLayout.PathElement.html#sequenceElement(long,long)"><code>MemoryLayout.PathElement.sequenceElement(long, long) </code></a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>).                    </dd>   </dl>  </section> <a end_ctx_id="method:bitOffsetHandle(java.lang.foreign.MemoryLayout.PathElement...)"/>   </td><td bgcolor="#FFFFFF" colspan="1"> <a start_ctx_id="method:bitOffsetHandle(java.lang.foreign.MemoryLayout.PathElement...)"/> <section class="detail" id="bitOffsetHandle(java.lang.foreign.MemoryLayout.PathElement...)"><h3>bitOffsetHandle</h3><div class="member-signature"> <span class="modifiers">default</span> <span class="return-type"><a href="../invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></span> <span class="element-name">bitOffsetHandle</span> <wbr/> <span class="parameters">(<a href="MemoryLayout.PathElement.html" title="interface in java.lang.foreign">MemoryLayout.PathElement</a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>... elements)</span>   </div><div class="block"> Creates a method handle that can be used to compute the offset, in bits, of the layout selected by the given layout path, where the path is considered rooted in this layout.<p> The returned method handle has a return type of <code>long</code>, and features as many <code>long</code> parameter types as there are free dimensions in the provided layout path (see <a href="MemoryLayout.PathElement.html#sequenceElement()"><code>MemoryLayout.PathElement.sequenceElement()</code></a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>), where the order of the parameters corresponds to the order of the path elements. The returned method handle can be used to compute a layout offset similar to <a href="#bitOffset(java.lang.foreign.MemoryLayout.PathElement...)"><code>bitOffset(PathElement...)</code></a>, but where some sequence indices are specified only when invoking the method handle.                                                                       </p><p>The final offset returned by the method handle is computed as follows:           </p><blockquote><pre>
                                                            <code>
 offset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)
 </code>
                                                        </pre></blockquote> where <code>x_1</code>, <code>x_2</code>, ... <code>x_n</code> are <em>dynamic</em> values provided as <code>long</code> arguments, whereas <code>c_1</code>, <code>c_2</code>, ... <code>c_m</code> are <em>static</em> offset constants and <code>s_0</code>, <code>s_1</code>, ... <code>s_n</code> are <em>static</em> stride constants which are derived from the layout path.                                                                     </div><dl class="notes"> <dt>Parameters:</dt><dd> <code>elements</code> - the layout path elements.      </dd> <dt>Returns:</dt><dd>a method handle that can be used to compute the bit offset of the layout element specified by the given layout path elements, when supplied with the missing sequence element indices.                              </dd> <dt>Throws:</dt><dd> <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the layout path contains one or more path elements that select multiple sequence element indices (see <a href="MemoryLayout.PathElement.html#sequenceElement(long,long)"><code>MemoryLayout.PathElement.sequenceElement(long, long) </code></a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>).                    </dd><dd> <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the layout path contains one or more dereference path elements (see <a href="MemoryLayout.PathElement.html#dereferenceElement()"><code>MemoryLayout.PathElement.dereferenceElement()</code></a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>).               </dd>   </dl>  </section> <a end_ctx_id="method:bitOffsetHandle(java.lang.foreign.MemoryLayout.PathElement...)"/>   </td></tr></table></td></tr></table><table border="0" cellpadding="1" cellspacing="0" width="100%"><tr><td><h3 class="ctxid">method:byteOffset(java.lang.foreign.MemoryLayout.PathElement...) [CHANGED]</h3></td></tr><tr><td><table border="0" cellpadding="5" cellspacing="1" bgcolor="black" width="100%"><tr valign="top"><td bgcolor="#EEEEEE" colspan="2"> <a start_ctx_id="method:byteOffset(java.lang.foreign.MemoryLayout.PathElement...)"/> <section class="detail" id="byteOffset(java.lang.foreign.MemoryLayout.PathElement...)"><h3>byteOffset</h3><div class="member-signature"> <span class="modifiers">default</span> <span class="return-type">long</span> <span class="element-name">byteOffset</span> <wbr/> <span class="parameters">(<a href="MemoryLayout.PathElement.html" title="interface in java.lang.foreign">MemoryLayout.PathElement</a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>... elements)</span>   </div><div class="block">Computes the offset, in bytes, of the layout selected by the given layout path, where the path is considered rooted in this layout.                      </div><dl class="notes"> <dt>Parameters:</dt><dd> <code>elements</code> - the layout path elements.      </dd> <dt>Returns:</dt><dd> The offset, in bytes, of the layout selected by the layout path in <code>elements</code>.              </dd> <dt>Throws:</dt><dd> <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the layout path does not select any layout nested in this layout, or if the layout path contains one or more path elements that select multiple sequence element indices (see <a href="MemoryLayout.PathElement.html#sequenceElement()"><code>MemoryLayout.PathElement.sequenceElement()</code></a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup> and <a href="MemoryLayout.PathElement.html#sequenceElement(long,long)"><code>MemoryLayout.PathElement.sequenceElement(long, long) </code></a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>).                                    </dd><dd> <code><a href="../IllegalArgumentException.html" title="class in java.lang"><span class="diff-html-added">IllegalArgumentException</span></a></code> <span class="diff-html-added">-</span> <span class="diff-html-added">if</span> <span class="diff-html-added">the</span> <span class="diff-html-added">layout</span> <span class="diff-html-added">path</span> <span class="diff-html-added">contains</span> <span class="diff-html-added">one</span> <span class="diff-html-added">or</span> <span class="diff-html-added">more</span> <span class="diff-html-added">dereference</span> <span class="diff-html-added">path</span> <span class="diff-html-added">elements</span> <span class="diff-html-added">(see</span> <a href="MemoryLayout.PathElement.html#dereferenceElement()"><code><span class="diff-html-added">MemoryLayout.PathElement.dereferenceElement()</span></code></a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement"><span class="diff-html-added">PREVIEW</span></a></sup><span class="diff-html-added">).</span>               </dd><dd> <code><a href="../UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if <code>bitOffset(elements)</code> is not a multiple of 8.          </dd><dd> <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - if either <code>elements == null  </code>, or if any of the elements in <code>elements</code> is <code>null</code>.               </dd>   </dl>  </section> <a end_ctx_id="method:byteOffset(java.lang.foreign.MemoryLayout.PathElement...)"/>   </td></tr><tr valign="top"><td bgcolor="#CCCCCC" colspan="1"> <a start_ctx_id="method:byteOffset(java.lang.foreign.MemoryLayout.PathElement...)"/> <section class="detail" id="byteOffset(java.lang.foreign.MemoryLayout.PathElement...)"><h3>byteOffset</h3><div class="member-signature"> <span class="modifiers">default</span> <span class="return-type">long</span> <span class="element-name">byteOffset</span> <wbr/> <span class="parameters">(<a href="MemoryLayout.PathElement.html" title="interface in java.lang.foreign">MemoryLayout.PathElement</a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>... elements)</span>   </div><div class="block">Computes the offset, in bytes, of the layout selected by the given layout path, where the path is considered rooted in this layout.                      </div><dl class="notes"> <dt>Parameters:</dt><dd> <code>elements</code> - the layout path elements.      </dd> <dt>Returns:</dt><dd> The offset, in bytes, of the layout selected by the layout path in <code>elements</code>.              </dd> <dt>Throws:</dt><dd> <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the layout path does not select any layout nested in this layout, or if the layout path contains one or more path elements that select multiple sequence element indices (see <a href="MemoryLayout.PathElement.html#sequenceElement()"><code>MemoryLayout.PathElement.sequenceElement()</code></a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup> and <a href="MemoryLayout.PathElement.html#sequenceElement(long,long)"><code>MemoryLayout.PathElement.sequenceElement(long, long) </code></a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>).                                    </dd><dd> <code><a href="../UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if <code>bitOffset(elements)</code> is not a multiple of 8.          </dd><dd> <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - if either <code>elements == null  </code>, or if any of the elements in <code>elements</code> is <code>null</code>.               </dd>   </dl>  </section> <a end_ctx_id="method:byteOffset(java.lang.foreign.MemoryLayout.PathElement...)"/>   </td><td bgcolor="#FFFFFF" colspan="1"> <a start_ctx_id="method:byteOffset(java.lang.foreign.MemoryLayout.PathElement...)"/> <section class="detail" id="byteOffset(java.lang.foreign.MemoryLayout.PathElement...)"><h3>byteOffset</h3><div class="member-signature"> <span class="modifiers">default</span> <span class="return-type">long</span> <span class="element-name">byteOffset</span> <wbr/> <span class="parameters">(<a href="MemoryLayout.PathElement.html" title="interface in java.lang.foreign">MemoryLayout.PathElement</a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>... elements)</span>   </div><div class="block">Computes the offset, in bytes, of the layout selected by the given layout path, where the path is considered rooted in this layout.                      </div><dl class="notes"> <dt>Parameters:</dt><dd> <code>elements</code> - the layout path elements.      </dd> <dt>Returns:</dt><dd> The offset, in bytes, of the layout selected by the layout path in <code>elements</code>.              </dd> <dt>Throws:</dt><dd> <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the layout path does not select any layout nested in this layout, or if the layout path contains one or more path elements that select multiple sequence element indices (see <a href="MemoryLayout.PathElement.html#sequenceElement()"><code>MemoryLayout.PathElement.sequenceElement()</code></a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup> and <a href="MemoryLayout.PathElement.html#sequenceElement(long,long)"><code>MemoryLayout.PathElement.sequenceElement(long, long) </code></a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>).                                    </dd><dd> <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the layout path contains one or more dereference path elements (see <a href="MemoryLayout.PathElement.html#dereferenceElement()"><code>MemoryLayout.PathElement.dereferenceElement()</code></a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>).               </dd><dd> <code><a href="../UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if <code>bitOffset(elements)</code> is not a multiple of 8.          </dd><dd> <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - if either <code>elements == null  </code>, or if any of the elements in <code>elements</code> is <code>null</code>.               </dd>   </dl>  </section> <a end_ctx_id="method:byteOffset(java.lang.foreign.MemoryLayout.PathElement...)"/>   </td></tr></table></td></tr></table><table border="0" cellpadding="1" cellspacing="0" width="100%"><tr><td><h3 class="ctxid">method:byteOffsetHandle(java.lang.foreign.MemoryLayout.PathElement...) [CHANGED]</h3></td></tr><tr><td><table border="0" cellpadding="5" cellspacing="1" bgcolor="black" width="100%"><tr valign="top"><td bgcolor="#EEEEEE" colspan="2"> <a start_ctx_id="method:byteOffsetHandle(java.lang.foreign.MemoryLayout.PathElement...)"/> <section class="detail" id="byteOffsetHandle(java.lang.foreign.MemoryLayout.PathElement...)"><h3>byteOffsetHandle</h3><div class="member-signature"> <span class="modifiers">default</span> <span class="return-type"><a href="../invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></span> <span class="element-name">byteOffsetHandle</span> <wbr/> <span class="parameters">(<a href="MemoryLayout.PathElement.html" title="interface in java.lang.foreign">MemoryLayout.PathElement</a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>... elements)</span>   </div><div class="block"> Creates a method handle that can be used to compute the offset, in bytes, of the layout selected by the given layout path, where the path is considered rooted in this layout.<p> The returned method handle has a return type of <code>long</code>, and features as many <code>long</code> parameter types as there are free dimensions in the provided layout path (see <a href="MemoryLayout.PathElement.html#sequenceElement()"><code>MemoryLayout.PathElement.sequenceElement()</code></a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>), where the order of the parameters corresponds to the order of the path elements. The returned method handle can be used to compute a layout offset similar to <a href="#byteOffset(java.lang.foreign.MemoryLayout.PathElement...)"><code>byteOffset(PathElement...)</code></a>, but where some sequence indices are specified only when invoking the method handle.                                                                       </p><p>The final offset returned by the method handle is computed as follows:           </p><blockquote><pre>
                                                            <code>
 bitOffset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)
 offset = bitOffset / 8
 </code>
                                                        </pre></blockquote> where <code>x_1</code>, <code>x_2</code>, ... <code>x_n</code> are <em>dynamic</em> values provided as <code>long</code> arguments, whereas <code>c_1</code>, <code>c_2</code>, ... <code>c_m</code> are <em>static</em> offset constants and <code>s_0</code>, <code>s_1</code>, ... <code>s_n</code> are <em>static</em> stride constants which are derived from the layout path.<p> The method handle will throw an <a href="../UnsupportedOperationException.html" title="class in java.lang"><code>UnsupportedOperationException</code></a> if the computed offset in bits is not a multiple of 8.                   </p>                                                                     </div><dl class="notes"> <dt>Parameters:</dt><dd> <code>elements</code> - the layout path elements.      </dd> <dt>Returns:</dt><dd>a method handle that can be used to compute the byte offset of the layout element specified by the given layout path elements, when supplied with the missing sequence element indices.                              </dd> <dt>Throws:</dt><dd> <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the layout path contains one or more path elements that select multiple sequence element indices (see <a href="MemoryLayout.PathElement.html#sequenceElement(long,long)"><code>MemoryLayout.PathElement.sequenceElement(long, long) </code></a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>).                    </dd><dd> <code><a href="../IllegalArgumentException.html" title="class in java.lang"><span class="diff-html-added">IllegalArgumentException</span></a></code> <span class="diff-html-added">-</span> <span class="diff-html-added">if</span> <span class="diff-html-added">the</span> <span class="diff-html-added">layout</span> <span class="diff-html-added">path</span> <span class="diff-html-added">contains</span> <span class="diff-html-added">one</span> <span class="diff-html-added">or</span> <span class="diff-html-added">more</span> <span class="diff-html-added">dereference</span> <span class="diff-html-added">path</span> <span class="diff-html-added">elements</span> <span class="diff-html-added">(see</span> <a href="MemoryLayout.PathElement.html#dereferenceElement()"><code><span class="diff-html-added">MemoryLayout.PathElement.dereferenceElement()</span></code></a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement"><span class="diff-html-added">PREVIEW</span></a></sup><span class="diff-html-added">).</span>               </dd>   </dl>  </section> <a end_ctx_id="method:byteOffsetHandle(java.lang.foreign.MemoryLayout.PathElement...)"/>   </td></tr><tr valign="top"><td bgcolor="#CCCCCC" colspan="1"> <a start_ctx_id="method:byteOffsetHandle(java.lang.foreign.MemoryLayout.PathElement...)"/> <section class="detail" id="byteOffsetHandle(java.lang.foreign.MemoryLayout.PathElement...)"><h3>byteOffsetHandle</h3><div class="member-signature"> <span class="modifiers">default</span> <span class="return-type"><a href="../invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></span> <span class="element-name">byteOffsetHandle</span> <wbr/> <span class="parameters">(<a href="MemoryLayout.PathElement.html" title="interface in java.lang.foreign">MemoryLayout.PathElement</a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>... elements)</span>   </div><div class="block"> Creates a method handle that can be used to compute the offset, in bytes, of the layout selected by the given layout path, where the path is considered rooted in this layout.<p> The returned method handle has a return type of <code>long</code>, and features as many <code>long</code> parameter types as there are free dimensions in the provided layout path (see <a href="MemoryLayout.PathElement.html#sequenceElement()"><code>MemoryLayout.PathElement.sequenceElement()</code></a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>), where the order of the parameters corresponds to the order of the path elements. The returned method handle can be used to compute a layout offset similar to <a href="#byteOffset(java.lang.foreign.MemoryLayout.PathElement...)"><code>byteOffset(PathElement...)</code></a>, but where some sequence indices are specified only when invoking the method handle.                                                                       </p><p>The final offset returned by the method handle is computed as follows:           </p><blockquote><pre>
                                                            <code>
 bitOffset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)
 offset = bitOffset / 8
 </code>
                                                        </pre></blockquote> where <code>x_1</code>, <code>x_2</code>, ... <code>x_n</code> are <em>dynamic</em> values provided as <code>long</code> arguments, whereas <code>c_1</code>, <code>c_2</code>, ... <code>c_m</code> are <em>static</em> offset constants and <code>s_0</code>, <code>s_1</code>, ... <code>s_n</code> are <em>static</em> stride constants which are derived from the layout path.<p> The method handle will throw an <a href="../UnsupportedOperationException.html" title="class in java.lang"><code>UnsupportedOperationException</code></a> if the computed offset in bits is not a multiple of 8.                   </p>                                                                     </div><dl class="notes"> <dt>Parameters:</dt><dd> <code>elements</code> - the layout path elements.      </dd> <dt>Returns:</dt><dd>a method handle that can be used to compute the byte offset of the layout element specified by the given layout path elements, when supplied with the missing sequence element indices.                              </dd> <dt>Throws:</dt><dd> <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the layout path contains one or more path elements that select multiple sequence element indices (see <a href="MemoryLayout.PathElement.html#sequenceElement(long,long)"><code>MemoryLayout.PathElement.sequenceElement(long, long) </code></a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>).                    </dd>   </dl>  </section> <a end_ctx_id="method:byteOffsetHandle(java.lang.foreign.MemoryLayout.PathElement...)"/>   </td><td bgcolor="#FFFFFF" colspan="1"> <a start_ctx_id="method:byteOffsetHandle(java.lang.foreign.MemoryLayout.PathElement...)"/> <section class="detail" id="byteOffsetHandle(java.lang.foreign.MemoryLayout.PathElement...)"><h3>byteOffsetHandle</h3><div class="member-signature"> <span class="modifiers">default</span> <span class="return-type"><a href="../invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></span> <span class="element-name">byteOffsetHandle</span> <wbr/> <span class="parameters">(<a href="MemoryLayout.PathElement.html" title="interface in java.lang.foreign">MemoryLayout.PathElement</a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>... elements)</span>   </div><div class="block"> Creates a method handle that can be used to compute the offset, in bytes, of the layout selected by the given layout path, where the path is considered rooted in this layout.<p> The returned method handle has a return type of <code>long</code>, and features as many <code>long</code> parameter types as there are free dimensions in the provided layout path (see <a href="MemoryLayout.PathElement.html#sequenceElement()"><code>MemoryLayout.PathElement.sequenceElement()</code></a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>), where the order of the parameters corresponds to the order of the path elements. The returned method handle can be used to compute a layout offset similar to <a href="#byteOffset(java.lang.foreign.MemoryLayout.PathElement...)"><code>byteOffset(PathElement...)</code></a>, but where some sequence indices are specified only when invoking the method handle.                                                                       </p><p>The final offset returned by the method handle is computed as follows:           </p><blockquote><pre>
                                                            <code>
 bitOffset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)
 offset = bitOffset / 8
 </code>
                                                        </pre></blockquote> where <code>x_1</code>, <code>x_2</code>, ... <code>x_n</code> are <em>dynamic</em> values provided as <code>long</code> arguments, whereas <code>c_1</code>, <code>c_2</code>, ... <code>c_m</code> are <em>static</em> offset constants and <code>s_0</code>, <code>s_1</code>, ... <code>s_n</code> are <em>static</em> stride constants which are derived from the layout path.<p> The method handle will throw an <a href="../UnsupportedOperationException.html" title="class in java.lang"><code>UnsupportedOperationException</code></a> if the computed offset in bits is not a multiple of 8.                   </p>                                                                     </div><dl class="notes"> <dt>Parameters:</dt><dd> <code>elements</code> - the layout path elements.      </dd> <dt>Returns:</dt><dd>a method handle that can be used to compute the byte offset of the layout element specified by the given layout path elements, when supplied with the missing sequence element indices.                              </dd> <dt>Throws:</dt><dd> <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the layout path contains one or more path elements that select multiple sequence element indices (see <a href="MemoryLayout.PathElement.html#sequenceElement(long,long)"><code>MemoryLayout.PathElement.sequenceElement(long, long) </code></a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>).                    </dd><dd> <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the layout path contains one or more dereference path elements (see <a href="MemoryLayout.PathElement.html#dereferenceElement()"><code>MemoryLayout.PathElement.dereferenceElement()</code></a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>).               </dd>   </dl>  </section> <a end_ctx_id="method:byteOffsetHandle(java.lang.foreign.MemoryLayout.PathElement...)"/>   </td></tr></table></td></tr></table><table border="0" cellpadding="1" cellspacing="0" width="100%"><tr><td><h3 class="ctxid">method:varHandle(java.lang.foreign.MemoryLayout.PathElement...) [CHANGED]</h3></td></tr><tr><td><table border="0" cellpadding="5" cellspacing="1" bgcolor="black" width="100%"><tr valign="top"><td bgcolor="#EEEEEE" colspan="2"> <a start_ctx_id="method:varHandle(java.lang.foreign.MemoryLayout.PathElement...)"/> <section class="detail" id="varHandle(java.lang.foreign.MemoryLayout.PathElement...)"><h3>varHandle</h3><div class="member-signature"> <span class="modifiers">default</span> <span class="return-type"><a href="../invoke/VarHandle.html" title="class in java.lang.invoke">VarHandle</a></span> <span class="element-name">varHandle</span> <wbr/> <span class="parameters">(<a href="MemoryLayout.PathElement.html" title="interface in java.lang.foreign">MemoryLayout.PathElement</a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>... elements)</span>   </div><div class="block"> Creates a var handle that can be used to access a memory segment at the layout selected by the given layout path, where the path is considered rooted in this layout.<p> The final address accessed by the returned var handle can be computed as follows:              </p><blockquote><pre>
                                                            <code>
 address = base(segment) + offset
 </code>
                                                        </pre></blockquote> Where <code>base(segment)</code> denotes a function that returns the physical base address of the accessed memory segment. For native segments, this function just returns the native segment's <a href="MemorySegment.html#address()">address</a><sup><a href="MemorySegment.html#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup>. For heap segments, this function is more complex, as the address of heap segments is virtualized. The <code>offset</code> coordinate can be expressed in the following form:<blockquote><pre>
                                                            <code>
 offset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)
 </code>
                                                        </pre></blockquote> where <code>x_1</code>, <code>x_2</code>, ... <code>x_n</code> are <em>dynamic</em> values provided as <code>long</code> arguments, whereas <code>c_1</code>, <code>c_2</code>, ... <code>c_m</code> are <em>static</em> offset constants and <code>s_1</code>, <code>s_2</code>, ... <code>s_n</code> are <em>static</em> stride constants which are derived from the layout path.<p> Additionally, the provided dynamic values must conform to some bound which is derived from the layout path, that is, <code>0 &lt;= x_i &lt; b_i    </code>, where <code>1 &lt;= i &lt;= n    </code>, or <a href="../IndexOutOfBoundsException.html" title="class in java.lang"><code>IndexOutOfBoundsException</code></a> is thrown.                          </p><p> <span class="diff-html-added">Multiple</span> <span class="diff-html-added">paths</span> <span class="diff-html-added">can</span> <span class="diff-html-added">be</span> <span class="diff-html-added">chained,</span> <span class="diff-html-added">by</span> <span class="diff-html-added">using</span> <a href="MemoryLayout.PathElement.html#dereferenceElement()"><span class="diff-html-added">dereference</span> <span class="diff-html-added">path</span> <span class="diff-html-added">elements</span>  </a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement"><span class="diff-html-added">PREVIEW</span></a></sup><span class="diff-html-added">.</span> <span class="diff-html-added">A</span> <span class="diff-html-added">dereference</span> <span class="diff-html-added">path</span> <span class="diff-html-added">element</span> <span class="diff-html-added">allows</span> <span class="diff-html-added">to</span> <span class="diff-html-added">obtain</span> <span class="diff-html-added">a</span> <span class="diff-html-added">native</span> <span class="diff-html-added">memory</span> <span class="diff-html-added">segment</span> <span class="diff-html-added">whose</span> <span class="diff-html-added">base</span> <span class="diff-html-added">address</span> <span class="diff-html-added">is</span> <span class="diff-html-added">the</span> <span class="diff-html-added">address</span> <span class="diff-html-added">obtained</span> <span class="diff-html-added">by</span> <span class="diff-html-added">following</span> <span class="diff-html-added">the</span> <span class="diff-html-added">layout</span> <span class="diff-html-added">path</span> <span class="diff-html-added">elements</span> <span class="diff-html-added">immediately</span> <span class="diff-html-added">preceding</span> <span class="diff-html-added">the</span> <span class="diff-html-added">dereference</span> <span class="diff-html-added">path</span> <span class="diff-html-added">element.</span> <span class="diff-html-added">In</span> <span class="diff-html-added">other</span> <span class="diff-html-added">words,</span> <span class="diff-html-added">if</span> <span class="diff-html-added">a</span> <span class="diff-html-added">layout</span> <span class="diff-html-added">path</span> <span class="diff-html-added">contains</span> <span class="diff-html-added">one</span> <span class="diff-html-added">or</span> <span class="diff-html-added">more</span> <span class="diff-html-added">dereference</span> <span class="diff-html-added">path</span> <span class="diff-html-added">elements,</span> <span class="diff-html-added">the</span> <span class="diff-html-added">final</span> <span class="diff-html-added">address</span> <span class="diff-html-added">accessed</span> <span class="diff-html-added">by</span> <span class="diff-html-added">the</span> <span class="diff-html-added">returned</span> <span class="diff-html-added">var</span> <span class="diff-html-added">handle</span> <span class="diff-html-added">can</span> <span class="diff-html-added">be</span> <span class="diff-html-added">computed</span> <span class="diff-html-added">as</span> <span class="diff-html-added">follows:</span>                                                                  </p><blockquote><pre>
                                                            <code>
 <span class="diff-html-added">address_1</span> <span class="diff-html-added">=</span> <span class="diff-html-added">base(segment)</span> <span class="diff-html-added">+</span> <span class="diff-html-added">offset_1</span>
 <span class="diff-html-added">address_2</span> <span class="diff-html-added">=</span> <span class="diff-html-added">base(segment_1)</span> <span class="diff-html-added">+</span> <span class="diff-html-added">offset_2</span>
 <span class="diff-html-added">...</span>
 <span class="diff-html-added">address_k</span> <span class="diff-html-added">=</span> <span class="diff-html-added">base(segment_k-1)</span> <span class="diff-html-added">+</span> <span class="diff-html-added">offset_k</span>
 </code>
                                                        </pre></blockquote> <span class="diff-html-added">where</span> <code><span class="diff-html-added">k</span></code> <span class="diff-html-added">is</span> <span class="diff-html-added">the</span> <span class="diff-html-added">number</span> <span class="diff-html-added">of</span> <span class="diff-html-added">dereference</span> <span class="diff-html-added">path</span> <span class="diff-html-added">elements</span> <span class="diff-html-added">in</span> <span class="diff-html-added">a</span> <span class="diff-html-added">layout</span> <span class="diff-html-added">path,</span> <code><span class="diff-html-added">segment</span></code> <span class="diff-html-added">is</span> <span class="diff-html-added">the</span> <span class="diff-html-added">input</span> <span class="diff-html-added">segment,</span> <code><span class="diff-html-added">segment_1</span></code><span class="diff-html-added">,</span> <span class="diff-html-added">...</span> <code><span class="diff-html-added">segment_k-1</span></code> <span class="diff-html-added">are</span> <span class="diff-html-added">the</span> <span class="diff-html-added">segments</span> <span class="diff-html-added">obtained</span> <span class="diff-html-added">by</span> <span class="diff-html-added">dereferencing</span> <span class="diff-html-added">the</span> <span class="diff-html-added">address</span> <span class="diff-html-added">associated</span> <span class="diff-html-added">with</span> <span class="diff-html-added">a</span> <span class="diff-html-added">given</span> <span class="diff-html-added">dereference</span> <span class="diff-html-added">path</span> <span class="diff-html-added">element</span> <span class="diff-html-added">(e.g.</span> <code><span class="diff-html-added">segment_1</span></code> <span class="diff-html-added">is</span> <span class="diff-html-added">a</span> <span class="diff-html-added">native</span> <span class="diff-html-added">segment</span> <span class="diff-html-added">whose</span> <span class="diff-html-added">base</span> <span class="diff-html-added">address</span> <span class="diff-html-added">is</span> <code><span class="diff-html-added">address_1</span></code><span class="diff-html-added">),</span> <span class="diff-html-added">and</span> <code><span class="diff-html-added">offset_1</span></code><span class="diff-html-added">,</span> <code><span class="diff-html-added">offset_2</span></code><span class="diff-html-added">,</span> <span class="diff-html-added">...</span> <code><span class="diff-html-added">offset_k</span></code> <span class="diff-html-added">are</span> <span class="diff-html-added">the</span> <span class="diff-html-added">offsets</span> <span class="diff-html-added">computed</span> <span class="diff-html-added">by</span> <span class="diff-html-added">evaluating</span> <span class="diff-html-added">the</span> <span class="diff-html-added">path</span> <span class="diff-html-added">elements</span> <span class="diff-html-added">after</span> <span class="diff-html-added">a</span> <span class="diff-html-added">given</span> <span class="diff-html-added">dereference</span> <span class="diff-html-added">operation</span> <span class="diff-html-added">(these</span> <span class="diff-html-added">offsets</span> <span class="diff-html-added">are</span> <span class="diff-html-added">obtained</span> <span class="diff-html-added">using</span> <span class="diff-html-added">the</span> <span class="diff-html-added">computation</span> <span class="diff-html-added">described</span> <span class="diff-html-added">above).</span> <span class="diff-html-added">In</span> <span class="diff-html-added">these</span> <span class="diff-html-added">more</span> <span class="diff-html-added">complex</span> <span class="diff-html-added">access</span> <span class="diff-html-added">operations,</span> <span class="diff-html-added">all</span> <span class="diff-html-added">memory</span> <span class="diff-html-added">accesses</span> <span class="diff-html-added">immediately</span> <span class="diff-html-added">preceding</span> <span class="diff-html-added">a</span> <span class="diff-html-added">dereference</span> <span class="diff-html-added">operation</span> <span class="diff-html-added">(e.g.</span> <span class="diff-html-added">those</span> <span class="diff-html-added">at</span> <span class="diff-html-added">addresses</span> <code><span class="diff-html-added">address_1</span></code><span class="diff-html-added">,</span> <code><span class="diff-html-added">address_2</span></code><span class="diff-html-added">,</span> <span class="diff-html-added">...,</span> <code><span class="diff-html-added">address_k-1</span></code> <span class="diff-html-added">are</span> <span class="diff-html-added">performed</span> <span class="diff-html-added">using</span> <span class="diff-html-added">the</span> <a href="../invoke/VarHandle.AccessMode.html#GET"><code><span class="diff-html-added">VarHandle.AccessMode.GET</span></code></a> <span class="diff-html-added">access</span> <span class="diff-html-added">mode.</span>                                                                                                                                                                                                                                 </div><dl class="notes"> <dt>API Note: </dt><dd> the resulting var handle will feature an additional <code>long</code> access coordinate for every unspecified sequence access component contained in this layout path. Moreover, the resulting var handle features certain <em>access mode restrictions  </em>, which are common to all memory segment view handles.                                       </dd> <dt>Parameters:</dt><dd> <code>elements</code> - the layout path elements.      </dd> <dt>Returns:</dt><dd> a var handle which can be used to access a memory segment at the (possibly nested) layout selected by the layout path in <code>elements</code>.                        </dd> <dt>Throws:</dt><dd> <code><a href="../UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if the layout path has one or more elements with incompatible alignment constraint.               </dd><dd> <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the layout path in <code>elements</code> does not select a value layout (see <a href="ValueLayout.html" title="interface in java.lang.foreign"><code>ValueLayout</code></a><sup><a href="ValueLayout.html#preview-java.lang.foreign.ValueLayout">PREVIEW</a></sup>)<span class="diff-html-added">.</span>                </dd><dd> <code><a href="../IllegalArgumentException.html" title="class in java.lang"><span class="diff-html-added">IllegalArgumentException</span></a></code> <span class="diff-html-added">-</span> <span class="diff-html-added">if</span> <span class="diff-html-added">the</span> <span class="diff-html-added">layout</span> <span class="diff-html-added">path</span> <span class="diff-html-added">in</span> <code><span class="diff-html-added">elements</span></code> <span class="diff-html-added">contains</span> <span class="diff-html-added">a</span> <a href="MemoryLayout.PathElement.html#dereferenceElement()"><span class="diff-html-added">dereference</span> <span class="diff-html-added">path</span> <span class="diff-html-added">element</span>  </a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement"><span class="diff-html-added">PREVIEW</span></a></sup> <span class="diff-html-added">for</span> <span class="diff-html-added">an</span> <span class="diff-html-added">address</span> <span class="diff-html-added">layout</span> <span class="diff-html-added">that</span> <span class="diff-html-added">has</span> <span class="diff-html-added">no</span> <a href="ValueLayout.OfAddress.html#targetLayout()"><span class="diff-html-added">target</span> <span class="diff-html-added">layout</span> </a><sup><a href="ValueLayout.OfAddress.html#preview-java.lang.foreign.ValueLayout.OfAddress"><span class="diff-html-added">PREVIEW</span></a></sup>.                   </dd> <dt>See Also: </dt><dd><ul class="tag-list-long"><li> <a href="../invoke/MethodHandles.html#memorySegmentViewVarHandle(java.lang.foreign.ValueLayout)"><code>MethodHandles.memorySegmentViewVarHandle(ValueLayout)</code></a><sup><a href="../invoke/MethodHandles.html#preview-memorySegmentViewVarHandle(java.lang.foreign.ValueLayout)">PREVIEW</a></sup> </li></ul></dd>     </dl>  </section> <a end_ctx_id="method:varHandle(java.lang.foreign.MemoryLayout.PathElement...)"/>   </td></tr><tr valign="top"><td bgcolor="#CCCCCC" colspan="1"> <a start_ctx_id="method:varHandle(java.lang.foreign.MemoryLayout.PathElement...)"/> <section class="detail" id="varHandle(java.lang.foreign.MemoryLayout.PathElement...)"><h3>varHandle</h3><div class="member-signature"> <span class="modifiers">default</span> <span class="return-type"><a href="../invoke/VarHandle.html" title="class in java.lang.invoke">VarHandle</a></span> <span class="element-name">varHandle</span> <wbr/> <span class="parameters">(<a href="MemoryLayout.PathElement.html" title="interface in java.lang.foreign">MemoryLayout.PathElement</a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>... elements)</span>   </div><div class="block"> Creates a var handle that can be used to access a memory segment at the layout selected by the given layout path, where the path is considered rooted in this layout.<p> The final address accessed by the returned var handle can be computed as follows:              </p><blockquote><pre>
                                                            <code>
 address = base(segment) + offset
 </code>
                                                        </pre></blockquote> Where <code>base(segment)</code> denotes a function that returns the physical base address of the accessed memory segment. For native segments, this function just returns the native segment's <a href="MemorySegment.html#address()">address</a><sup><a href="MemorySegment.html#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup>. For heap segments, this function is more complex, as the address of heap segments is virtualized. The <code>offset</code> coordinate can be expressed in the following form:<blockquote><pre>
                                                            <code>
 offset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)
 </code>
                                                        </pre></blockquote> where <code>x_1</code>, <code>x_2</code>, ... <code>x_n</code> are <em>dynamic</em> values provided as <code>long</code> arguments, whereas <code>c_1</code>, <code>c_2</code>, ... <code>c_m</code> are <em>static</em> offset constants and <code>s_1</code>, <code>s_2</code>, ... <code>s_n</code> are <em>static</em> stride constants which are derived from the layout path.<p> Additionally, the provided dynamic values must conform to some bound which is derived from the layout path, that is, <code>0 &lt;= x_i &lt; b_i    </code>, where <code>1 &lt;= i &lt;= n    </code>, or <a href="../IndexOutOfBoundsException.html" title="class in java.lang"><code>IndexOutOfBoundsException</code></a> is thrown.                          </p>                                                                                                                         </div><dl class="notes"> <dt>API Note: </dt><dd> the resulting var handle will feature an additional <code>long</code> access coordinate for every unspecified sequence access component contained in this layout path. Moreover, the resulting var handle features certain <em>access mode restrictions  </em>, which are common to all memory segment view handles.                                       </dd> <dt>Parameters:</dt><dd> <code>elements</code> - the layout path elements.      </dd> <dt>Returns:</dt><dd> a var handle which can be used to access a memory segment at the (possibly nested) layout selected by the layout path in <code>elements</code>.                        </dd> <dt>Throws:</dt><dd> <code><a href="../UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if the layout path has one or more elements with incompatible alignment constraint.               </dd><dd> <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the layout path in <code>elements</code> does not select a value layout (see <a href="ValueLayout.html" title="interface in java.lang.foreign"><code>ValueLayout</code></a><sup><a href="ValueLayout.html#preview-java.lang.foreign.ValueLayout">PREVIEW</a></sup>).                </dd> <dt>See Also: </dt><dd><ul class="tag-list-long"><li> <a href="../invoke/MethodHandles.html#memorySegmentViewVarHandle(java.lang.foreign.ValueLayout)"><code>MethodHandles.memorySegmentViewVarHandle(ValueLayout)</code></a><sup><a href="../invoke/MethodHandles.html#preview-memorySegmentViewVarHandle(java.lang.foreign.ValueLayout)">PREVIEW</a></sup> </li></ul></dd>     </dl>  </section> <a end_ctx_id="method:varHandle(java.lang.foreign.MemoryLayout.PathElement...)"/>   </td><td bgcolor="#FFFFFF" colspan="1"> <a start_ctx_id="method:varHandle(java.lang.foreign.MemoryLayout.PathElement...)"/> <section class="detail" id="varHandle(java.lang.foreign.MemoryLayout.PathElement...)"><h3>varHandle</h3><div class="member-signature"> <span class="modifiers">default</span> <span class="return-type"><a href="../invoke/VarHandle.html" title="class in java.lang.invoke">VarHandle</a></span> <span class="element-name">varHandle</span> <wbr/> <span class="parameters">(<a href="MemoryLayout.PathElement.html" title="interface in java.lang.foreign">MemoryLayout.PathElement</a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>... elements)</span>   </div><div class="block"> Creates a var handle that can be used to access a memory segment at the layout selected by the given layout path, where the path is considered rooted in this layout.<p> The final address accessed by the returned var handle can be computed as follows:              </p><blockquote><pre>
                                                            <code>
 address = base(segment) + offset
 </code>
                                                        </pre></blockquote> Where <code>base(segment)</code> denotes a function that returns the physical base address of the accessed memory segment. For native segments, this function just returns the native segment's <a href="MemorySegment.html#address()">address</a><sup><a href="MemorySegment.html#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup>. For heap segments, this function is more complex, as the address of heap segments is virtualized. The <code>offset</code> coordinate can be expressed in the following form:<blockquote><pre>
                                                            <code>
 offset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)
 </code>
                                                        </pre></blockquote> where <code>x_1</code>, <code>x_2</code>, ... <code>x_n</code> are <em>dynamic</em> values provided as <code>long</code> arguments, whereas <code>c_1</code>, <code>c_2</code>, ... <code>c_m</code> are <em>static</em> offset constants and <code>s_1</code>, <code>s_2</code>, ... <code>s_n</code> are <em>static</em> stride constants which are derived from the layout path.<p> Additionally, the provided dynamic values must conform to some bound which is derived from the layout path, that is, <code>0 &lt;= x_i &lt; b_i    </code>, where <code>1 &lt;= i &lt;= n    </code>, or <a href="../IndexOutOfBoundsException.html" title="class in java.lang"><code>IndexOutOfBoundsException</code></a> is thrown.                          </p><p> Multiple paths can be chained, by using <a href="MemoryLayout.PathElement.html#dereferenceElement()">dereference path elements  </a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>. A dereference path element allows to obtain a native memory segment whose base address is the address obtained by following the layout path elements immediately preceding the dereference path element. In other words, if a layout path contains one or more dereference path elements, the final address accessed by the returned var handle can be computed as follows:                                                                  </p><blockquote><pre>
                                                            <code>
 address_1 = base(segment) + offset_1
 address_2 = base(segment_1) + offset_2
 ...
 address_k = base(segment_k-1) + offset_k
 </code>
                                                        </pre></blockquote> where <code>k</code> is the number of dereference path elements in a layout path, <code>segment</code> is the input segment, <code>segment_1</code>, ... <code>segment_k-1</code> are the segments obtained by dereferencing the address associated with a given dereference path element (e.g. <code>segment_1</code> is a native segment whose base address is <code>address_1</code>), and <code>offset_1</code>, <code>offset_2</code>, ... <code>offset_k</code> are the offsets computed by evaluating the path elements after a given dereference operation (these offsets are obtained using the computation described above). In these more complex access operations, all memory accesses immediately preceding a dereference operation (e.g. those at addresses <code>address_1</code>, <code>address_2</code>, ..., <code>address_k-1</code> are performed using the <a href="../invoke/VarHandle.AccessMode.html#GET"><code>VarHandle.AccessMode.GET</code></a> access mode.                                                                                                                                                                                                                                 </div><dl class="notes"> <dt>API Note: </dt><dd> the resulting var handle will feature an additional <code>long</code> access coordinate for every unspecified sequence access component contained in this layout path. Moreover, the resulting var handle features certain <em>access mode restrictions  </em>, which are common to all memory segment view handles.                                       </dd> <dt>Parameters:</dt><dd> <code>elements</code> - the layout path elements.      </dd> <dt>Returns:</dt><dd> a var handle which can be used to access a memory segment at the (possibly nested) layout selected by the layout path in <code>elements</code>.                        </dd> <dt>Throws:</dt><dd> <code><a href="../UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if the layout path has one or more elements with incompatible alignment constraint.               </dd><dd> <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the layout path in <code>elements</code> does not select a value layout (see <a href="ValueLayout.html" title="interface in java.lang.foreign"><code>ValueLayout</code></a><sup><a href="ValueLayout.html#preview-java.lang.foreign.ValueLayout">PREVIEW</a></sup>).                </dd><dd> <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the layout path in <code>elements</code> contains a <a href="MemoryLayout.PathElement.html#dereferenceElement()">dereference path element  </a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup> for an address layout that has no <a href="ValueLayout.OfAddress.html#targetLayout()">target layout </a><sup><a href="ValueLayout.OfAddress.html#preview-java.lang.foreign.ValueLayout.OfAddress">PREVIEW</a></sup>.                   </dd> <dt>See Also: </dt><dd><ul class="tag-list-long"><li> <a href="../invoke/MethodHandles.html#memorySegmentViewVarHandle(java.lang.foreign.ValueLayout)"><code>MethodHandles.memorySegmentViewVarHandle(ValueLayout)</code></a><sup><a href="../invoke/MethodHandles.html#preview-memorySegmentViewVarHandle(java.lang.foreign.ValueLayout)">PREVIEW</a></sup> </li></ul></dd>     </dl>  </section> <a end_ctx_id="method:varHandle(java.lang.foreign.MemoryLayout.PathElement...)"/>   </td></tr></table></td></tr></table><table border="0" cellpadding="1" cellspacing="0" width="100%"><tr><td><h3 class="ctxid">method:sliceHandle(java.lang.foreign.MemoryLayout.PathElement...) [CHANGED]</h3></td></tr><tr><td><table border="0" cellpadding="5" cellspacing="1" bgcolor="black" width="100%"><tr valign="top"><td bgcolor="#EEEEEE" colspan="2"> <a start_ctx_id="method:sliceHandle(java.lang.foreign.MemoryLayout.PathElement...)"/> <section class="detail" id="sliceHandle(java.lang.foreign.MemoryLayout.PathElement...)"><h3>sliceHandle</h3><div class="member-signature"> <span class="modifiers">default</span> <span class="return-type"><a href="../invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></span> <span class="element-name">sliceHandle</span> <wbr/> <span class="parameters">(<a href="MemoryLayout.PathElement.html" title="interface in java.lang.foreign">MemoryLayout.PathElement</a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>... elements)</span>   </div><div class="block"> Creates a method handle which, given a memory segment, returns a <a href="MemorySegment.html#asSlice(long,long)">slice</a><sup><a href="MemorySegment.html#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup> corresponding to the layout selected by the given layout path, where the path is considered rooted in this layout.<p> The returned method handle has a return type of <code>MemorySegment</code>, features a <code>MemorySegment</code> parameter as leading parameter representing the segment to be sliced, and features as many trailing <code>long</code> parameter types as there are free dimensions in the provided layout path (see <a href="MemoryLayout.PathElement.html#sequenceElement()"><code>MemoryLayout.PathElement.sequenceElement()</code></a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>), where the order of the parameters corresponds to the order of the path elements. The returned method handle can be used to create a slice similar to using <a href="MemorySegment.html#asSlice(long,long)"><code>MemorySegment.asSlice(long, long) </code></a><sup><a href="MemorySegment.html#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup>, but where the offset argument is dynamically compute based on indices specified when invoking the method handle.                                                                                         </p><p>The offset of the returned segment is computed as follows:         </p><blockquote><pre>
                                                            <code>
 bitOffset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)
 offset = bitOffset / 8
 </code>
                                                        </pre></blockquote> where <code>x_1</code>, <code>x_2</code>, ... <code>x_n</code> are <em>dynamic</em> values provided as <code>long</code> arguments, whereas <code>c_1</code>, <code>c_2</code>, ... <code>c_m</code> are <em>static</em> offset constants and <code>s_1</code>, <code>s_2</code>, ... <code>s_n</code> are <em>static</em> stride constants which are derived from the layout path.<p>After the offset is computed, the returned segment is created as if by calling:             </p><div class="snippet-container"> <button class="copy snippet-copy"><span data-copied="Copied!">Copy</span><img src="../../../../copy.svg" alt="Copy"/></button><pre class="snippet">
                                                            <code class="language-java">segment.asSlice(offset, layout.byteSize());
</code>
                                                        </pre> </div> where <code>segment</code> is the segment to be sliced, and where <code>layout</code> is the layout selected by the given layout path, as per <a href="#select(java.lang.foreign.MemoryLayout.PathElement...)"><code>select(PathElement...)</code></a>.<p> The method handle will throw an <a href="../UnsupportedOperationException.html" title="class in java.lang"><code>UnsupportedOperationException</code></a> if the computed offset in bits is not a multiple of 8.                   </p>                                                                                           </div><dl class="notes"> <dt>Parameters:</dt><dd> <code>elements</code> - the layout path elements.      </dd> <dt>Returns:</dt><dd>a method handle which can be used to create a slice of the selected layout element, given a segment.                  </dd> <dt>Throws:</dt><dd> <code><a href="../UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if the size of the selected layout in bits is not a multiple of 8.                 </dd><dd> <code><a href="../IllegalArgumentException.html" title="class in java.lang"><span class="diff-html-added">IllegalArgumentException</span></a></code> <span class="diff-html-added">-</span> <span class="diff-html-added">if</span> <span class="diff-html-added">the</span> <span class="diff-html-added">layout</span> <span class="diff-html-added">path</span> <span class="diff-html-added">contains</span> <span class="diff-html-added">one</span> <span class="diff-html-added">or</span> <span class="diff-html-added">more</span> <span class="diff-html-added">dereference</span> <span class="diff-html-added">path</span> <span class="diff-html-added">elements</span> <span class="diff-html-added">(see</span> <a href="MemoryLayout.PathElement.html#dereferenceElement()"><code><span class="diff-html-added">MemoryLayout.PathElement.dereferenceElement()</span></code></a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement"><span class="diff-html-added">PREVIEW</span></a></sup><span class="diff-html-added">).</span>               </dd>   </dl>  </section> <a end_ctx_id="method:sliceHandle(java.lang.foreign.MemoryLayout.PathElement...)"/>   </td></tr><tr valign="top"><td bgcolor="#CCCCCC" colspan="1"> <a start_ctx_id="method:sliceHandle(java.lang.foreign.MemoryLayout.PathElement...)"/> <section class="detail" id="sliceHandle(java.lang.foreign.MemoryLayout.PathElement...)"><h3>sliceHandle</h3><div class="member-signature"> <span class="modifiers">default</span> <span class="return-type"><a href="../invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></span> <span class="element-name">sliceHandle</span> <wbr/> <span class="parameters">(<a href="MemoryLayout.PathElement.html" title="interface in java.lang.foreign">MemoryLayout.PathElement</a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>... elements)</span>   </div><div class="block"> Creates a method handle which, given a memory segment, returns a <a href="MemorySegment.html#asSlice(long,long)">slice</a><sup><a href="MemorySegment.html#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup> corresponding to the layout selected by the given layout path, where the path is considered rooted in this layout.<p> The returned method handle has a return type of <code>MemorySegment</code>, features a <code>MemorySegment</code> parameter as leading parameter representing the segment to be sliced, and features as many trailing <code>long</code> parameter types as there are free dimensions in the provided layout path (see <a href="MemoryLayout.PathElement.html#sequenceElement()"><code>MemoryLayout.PathElement.sequenceElement()</code></a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>), where the order of the parameters corresponds to the order of the path elements. The returned method handle can be used to create a slice similar to using <a href="MemorySegment.html#asSlice(long,long)"><code>MemorySegment.asSlice(long, long) </code></a><sup><a href="MemorySegment.html#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup>, but where the offset argument is dynamically compute based on indices specified when invoking the method handle.                                                                                         </p><p>The offset of the returned segment is computed as follows:         </p><blockquote><pre>
                                                            <code>
 bitOffset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)
 offset = bitOffset / 8
 </code>
                                                        </pre></blockquote> where <code>x_1</code>, <code>x_2</code>, ... <code>x_n</code> are <em>dynamic</em> values provided as <code>long</code> arguments, whereas <code>c_1</code>, <code>c_2</code>, ... <code>c_m</code> are <em>static</em> offset constants and <code>s_1</code>, <code>s_2</code>, ... <code>s_n</code> are <em>static</em> stride constants which are derived from the layout path.<p>After the offset is computed, the returned segment is created as if by calling:             </p><div class="snippet-container"> <button class="copy snippet-copy"><span data-copied="Copied!">Copy</span><img src="../../../../copy.svg" alt="Copy"/></button><pre class="snippet">
                                                            <code class="language-java">segment.asSlice(offset, layout.byteSize());
</code>
                                                        </pre> </div> where <code>segment</code> is the segment to be sliced, and where <code>layout</code> is the layout selected by the given layout path, as per <a href="#select(java.lang.foreign.MemoryLayout.PathElement...)"><code>select(PathElement...)</code></a>.<p> The method handle will throw an <a href="../UnsupportedOperationException.html" title="class in java.lang"><code>UnsupportedOperationException</code></a> if the computed offset in bits is not a multiple of 8.                   </p>                                                                                           </div><dl class="notes"> <dt>Parameters:</dt><dd> <code>elements</code> - the layout path elements.      </dd> <dt>Returns:</dt><dd>a method handle which can be used to create a slice of the selected layout element, given a segment.                  </dd> <dt>Throws:</dt><dd> <code><a href="../UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if the size of the selected layout in bits is not a multiple of 8.                 </dd>   </dl>  </section> <a end_ctx_id="method:sliceHandle(java.lang.foreign.MemoryLayout.PathElement...)"/>   </td><td bgcolor="#FFFFFF" colspan="1"> <a start_ctx_id="method:sliceHandle(java.lang.foreign.MemoryLayout.PathElement...)"/> <section class="detail" id="sliceHandle(java.lang.foreign.MemoryLayout.PathElement...)"><h3>sliceHandle</h3><div class="member-signature"> <span class="modifiers">default</span> <span class="return-type"><a href="../invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></span> <span class="element-name">sliceHandle</span> <wbr/> <span class="parameters">(<a href="MemoryLayout.PathElement.html" title="interface in java.lang.foreign">MemoryLayout.PathElement</a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>... elements)</span>   </div><div class="block"> Creates a method handle which, given a memory segment, returns a <a href="MemorySegment.html#asSlice(long,long)">slice</a><sup><a href="MemorySegment.html#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup> corresponding to the layout selected by the given layout path, where the path is considered rooted in this layout.<p> The returned method handle has a return type of <code>MemorySegment</code>, features a <code>MemorySegment</code> parameter as leading parameter representing the segment to be sliced, and features as many trailing <code>long</code> parameter types as there are free dimensions in the provided layout path (see <a href="MemoryLayout.PathElement.html#sequenceElement()"><code>MemoryLayout.PathElement.sequenceElement()</code></a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>), where the order of the parameters corresponds to the order of the path elements. The returned method handle can be used to create a slice similar to using <a href="MemorySegment.html#asSlice(long,long)"><code>MemorySegment.asSlice(long, long) </code></a><sup><a href="MemorySegment.html#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup>, but where the offset argument is dynamically compute based on indices specified when invoking the method handle.                                                                                         </p><p>The offset of the returned segment is computed as follows:         </p><blockquote><pre>
                                                            <code>
 bitOffset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)
 offset = bitOffset / 8
 </code>
                                                        </pre></blockquote> where <code>x_1</code>, <code>x_2</code>, ... <code>x_n</code> are <em>dynamic</em> values provided as <code>long</code> arguments, whereas <code>c_1</code>, <code>c_2</code>, ... <code>c_m</code> are <em>static</em> offset constants and <code>s_1</code>, <code>s_2</code>, ... <code>s_n</code> are <em>static</em> stride constants which are derived from the layout path.<p>After the offset is computed, the returned segment is created as if by calling:             </p><div class="snippet-container"> <button class="copy snippet-copy"><span data-copied="Copied!">Copy</span><img src="../../../../copy.svg" alt="Copy"/></button><pre class="snippet">
                                                            <code class="language-java">segment.asSlice(offset, layout.byteSize());
</code>
                                                        </pre> </div> where <code>segment</code> is the segment to be sliced, and where <code>layout</code> is the layout selected by the given layout path, as per <a href="#select(java.lang.foreign.MemoryLayout.PathElement...)"><code>select(PathElement...)</code></a>.<p> The method handle will throw an <a href="../UnsupportedOperationException.html" title="class in java.lang"><code>UnsupportedOperationException</code></a> if the computed offset in bits is not a multiple of 8.                   </p>                                                                                           </div><dl class="notes"> <dt>Parameters:</dt><dd> <code>elements</code> - the layout path elements.      </dd> <dt>Returns:</dt><dd>a method handle which can be used to create a slice of the selected layout element, given a segment.                  </dd> <dt>Throws:</dt><dd> <code><a href="../UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if the size of the selected layout in bits is not a multiple of 8.                 </dd><dd> <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the layout path contains one or more dereference path elements (see <a href="MemoryLayout.PathElement.html#dereferenceElement()"><code>MemoryLayout.PathElement.dereferenceElement()</code></a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>).               </dd>   </dl>  </section> <a end_ctx_id="method:sliceHandle(java.lang.foreign.MemoryLayout.PathElement...)"/>   </td></tr></table></td></tr></table><table border="0" cellpadding="1" cellspacing="0" width="100%"><tr><td><h3 class="ctxid">method:select(java.lang.foreign.MemoryLayout.PathElement...) [CHANGED]</h3></td></tr><tr><td><table border="0" cellpadding="5" cellspacing="1" bgcolor="black" width="100%"><tr valign="top"><td bgcolor="#EEEEEE" colspan="2"> <a start_ctx_id="method:select(java.lang.foreign.MemoryLayout.PathElement...)"/> <section class="detail" id="select(java.lang.foreign.MemoryLayout.PathElement...)"><h3>select</h3><div class="member-signature"> <span class="modifiers">default</span> <span class="return-type"><a href="MemoryLayout.html" title="interface in java.lang.foreign">MemoryLayout</a><sup><a href="#preview-java.lang.foreign.MemoryLayout">PREVIEW</a></sup></span> <span class="element-name">select</span> <wbr/> <span class="parameters">(<a href="MemoryLayout.PathElement.html" title="interface in java.lang.foreign">MemoryLayout.PathElement</a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>... elements)</span>   </div><div class="block">Selects the layout from a path rooted in this layout.         </div><dl class="notes"> <dt>Parameters:</dt><dd> <code>elements</code> - the layout path elements.      </dd> <dt>Returns:</dt><dd> the layout selected by the layout path in <code>elements</code>.         </dd> <dt>Throws:</dt><dd> <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the layout path does not select any layout nested in this layout, or if the layout path contains one or more path elements that select one or more sequence element indices (see <a href="MemoryLayout.PathElement.html#sequenceElement(long)"><code>MemoryLayout.PathElement.sequenceElement(long)</code></a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup> and <a href="MemoryLayout.PathElement.html#sequenceElement(long,long)"><code>MemoryLayout.PathElement.sequenceElement(long, long) </code></a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>).                                      </dd><dd> <code><a href="../IllegalArgumentException.html" title="class in java.lang"><span class="diff-html-added">IllegalArgumentException</span></a></code> <span class="diff-html-added">-</span> <span class="diff-html-added">if</span> <span class="diff-html-added">the</span> <span class="diff-html-added">layout</span> <span class="diff-html-added">path</span> <span class="diff-html-added">contains</span> <span class="diff-html-added">one</span> <span class="diff-html-added">or</span> <span class="diff-html-added">more</span> <span class="diff-html-added">dereference</span> <span class="diff-html-added">path</span> <span class="diff-html-added">elements</span> <span class="diff-html-added">(see</span> <a href="MemoryLayout.PathElement.html#dereferenceElement()"><code><span class="diff-html-added">MemoryLayout.PathElement.dereferenceElement()</span></code></a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement"><span class="diff-html-added">PREVIEW</span></a></sup><span class="diff-html-added">).</span>               </dd>   </dl>  </section> <a end_ctx_id="method:select(java.lang.foreign.MemoryLayout.PathElement...)"/>   </td></tr><tr valign="top"><td bgcolor="#CCCCCC" colspan="1"> <a start_ctx_id="method:select(java.lang.foreign.MemoryLayout.PathElement...)"/> <section class="detail" id="select(java.lang.foreign.MemoryLayout.PathElement...)"><h3>select</h3><div class="member-signature"> <span class="modifiers">default</span> <span class="return-type"><a href="MemoryLayout.html" title="interface in java.lang.foreign">MemoryLayout</a><sup><a href="#preview-java.lang.foreign.MemoryLayout">PREVIEW</a></sup></span> <span class="element-name">select</span> <wbr/> <span class="parameters">(<a href="MemoryLayout.PathElement.html" title="interface in java.lang.foreign">MemoryLayout.PathElement</a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>... elements)</span>   </div><div class="block">Selects the layout from a path rooted in this layout.         </div><dl class="notes"> <dt>Parameters:</dt><dd> <code>elements</code> - the layout path elements.      </dd> <dt>Returns:</dt><dd> the layout selected by the layout path in <code>elements</code>.         </dd> <dt>Throws:</dt><dd> <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the layout path does not select any layout nested in this layout, or if the layout path contains one or more path elements that select one or more sequence element indices (see <a href="MemoryLayout.PathElement.html#sequenceElement(long)"><code>MemoryLayout.PathElement.sequenceElement(long)</code></a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup> and <a href="MemoryLayout.PathElement.html#sequenceElement(long,long)"><code>MemoryLayout.PathElement.sequenceElement(long, long) </code></a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>).                                      </dd>   </dl>  </section> <a end_ctx_id="method:select(java.lang.foreign.MemoryLayout.PathElement...)"/>   </td><td bgcolor="#FFFFFF" colspan="1"> <a start_ctx_id="method:select(java.lang.foreign.MemoryLayout.PathElement...)"/> <section class="detail" id="select(java.lang.foreign.MemoryLayout.PathElement...)"><h3>select</h3><div class="member-signature"> <span class="modifiers">default</span> <span class="return-type"><a href="MemoryLayout.html" title="interface in java.lang.foreign">MemoryLayout</a><sup><a href="#preview-java.lang.foreign.MemoryLayout">PREVIEW</a></sup></span> <span class="element-name">select</span> <wbr/> <span class="parameters">(<a href="MemoryLayout.PathElement.html" title="interface in java.lang.foreign">MemoryLayout.PathElement</a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>... elements)</span>   </div><div class="block">Selects the layout from a path rooted in this layout.         </div><dl class="notes"> <dt>Parameters:</dt><dd> <code>elements</code> - the layout path elements.      </dd> <dt>Returns:</dt><dd> the layout selected by the layout path in <code>elements</code>.         </dd> <dt>Throws:</dt><dd> <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the layout path does not select any layout nested in this layout, or if the layout path contains one or more path elements that select one or more sequence element indices (see <a href="MemoryLayout.PathElement.html#sequenceElement(long)"><code>MemoryLayout.PathElement.sequenceElement(long)</code></a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup> and <a href="MemoryLayout.PathElement.html#sequenceElement(long,long)"><code>MemoryLayout.PathElement.sequenceElement(long, long) </code></a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>).                                      </dd><dd> <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the layout path contains one or more dereference path elements (see <a href="MemoryLayout.PathElement.html#dereferenceElement()"><code>MemoryLayout.PathElement.dereferenceElement()</code></a><sup><a href="MemoryLayout.PathElement.html#preview-java.lang.foreign.MemoryLayout.PathElement">PREVIEW</a></sup>).               </dd>   </dl>  </section> <a end_ctx_id="method:select(java.lang.foreign.MemoryLayout.PathElement...)"/>   </td></tr></table></td></tr></table><table border="0" cellpadding="1" cellspacing="0" width="100%"><tr><td><h3 class="ctxid">method:equals(java.lang.Object) [NONE]</h3></td></tr><tr><td><table border="0" cellpadding="5" cellspacing="1" bgcolor="black" width="100%"><tr valign="top"><td bgcolor="#FFFFFF" colspan="1"> <a start_ctx_id="method:equals(java.lang.Object)"/> <section class="detail" id="equals(java.lang.Object)"><h3>equals</h3><div class="member-signature"> <span class="return-type">boolean</span> <span class="element-name">equals</span> <wbr/> <span class="parameters">(<a href="../Object.html" title="class in java.lang">Object</a> other)</span>   </div><div class="block"> Compares the specified object with this layout for equality. Returns <code>true</code> if and only if the specified object is also a layout, and it is equal to this layout. Two layouts are considered equal if they are of the same kind, have the same size, name and alignment constraint. Furthermore, depending on the layout kind, additional conditions must be satisfied:<ul><li> two value layouts are considered equal if they have the same <a href="ValueLayout.html#order()">order</a><sup><a href="ValueLayout.html#preview-java.lang.foreign.ValueLayout">PREVIEW</a></sup>, and <a href="ValueLayout.html#carrier()">carrier</a><sup><a href="ValueLayout.html#preview-java.lang.foreign.ValueLayout">PREVIEW</a></sup>              </li><li> two sequence layouts are considered equal if they have the same element count (see <a href="SequenceLayout.html#elementCount()"><code>SequenceLayout.elementCount()</code></a><sup><a href="SequenceLayout.html#preview-java.lang.foreign.SequenceLayout">PREVIEW</a></sup>), and if their element layouts (see <a href="SequenceLayout.html#elementLayout()"><code>SequenceLayout.elementLayout()</code></a><sup><a href="SequenceLayout.html#preview-java.lang.foreign.SequenceLayout">PREVIEW</a></sup>) are also equal                         </li><li> two group layouts are considered equal if they are of the same type (see <a href="StructLayout.html" title="interface in java.lang.foreign"><code>StructLayout</code></a><sup><a href="StructLayout.html#preview-java.lang.foreign.StructLayout">PREVIEW</a></sup>, <a href="UnionLayout.html" title="interface in java.lang.foreign"><code>UnionLayout</code></a><sup><a href="UnionLayout.html#preview-java.lang.foreign.UnionLayout">PREVIEW</a></sup>) and if their member layouts (see <a href="GroupLayout.html#memberLayouts()"><code>GroupLayout.memberLayouts()</code></a><sup><a href="GroupLayout.html#preview-java.lang.foreign.GroupLayout">PREVIEW</a></sup>) are also equal                          </li></ul>                                                            </div><dl class="notes"> <dt>Overrides:</dt><dd> <code><a href="../Object.html#equals(java.lang.Object)">equals</a></code> in class <code><a href="../Object.html" title="class in java.lang">Object</a></code>  </dd> <dt>Parameters:</dt><dd> <code>other</code> - the object to be compared for equality with this layout.            </dd> <dt>Returns:</dt><dd> <code>true</code> if the specified object is equal to this layout.          </dd> <dt>See Also: </dt><dd><ul class="tag-list"><li> <a href="../Object.html#hashCode()"><code>Object.hashCode()</code></a> </li><li> <a href="../../util/HashMap.html" title="class in java.util"><code>HashMap</code></a> </li></ul></dd>    </dl>  </section> <a end_ctx_id="method:equals(java.lang.Object)"/>   </td></tr></table></td></tr></table><table border="0" cellpadding="1" cellspacing="0" width="100%"><tr><td><h3 class="ctxid">method:hashCode() [NONE]</h3></td></tr><tr><td><table border="0" cellpadding="5" cellspacing="1" bgcolor="black" width="100%"><tr valign="top"><td bgcolor="#FFFFFF" colspan="1"> <a start_ctx_id="method:hashCode()"/> <section class="detail" id="hashCode()"><h3>hashCode</h3><div class="member-signature"> <span class="return-type">int</span> <span class="element-name">hashCode</span>() </div><div class="block">Returns the hash code value for this layout.       </div><dl class="notes"> <dt>Overrides:</dt><dd> <code><a href="../Object.html#hashCode()">hashCode</a></code> in class <code><a href="../Object.html" title="class in java.lang">Object</a></code>  </dd> <dt>Returns:</dt><dd>the hash code value for this layout      </dd> <dt>See Also: </dt><dd><ul class="tag-list-long"><li> <a href="../Object.html#equals(java.lang.Object)"><code>Object.equals(java.lang.Object)</code></a> </li><li> <a href="../System.html#identityHashCode(java.lang.Object)"><code>System.identityHashCode(java.lang.Object)</code></a> </li></ul></dd>   </dl>  </section> <a end_ctx_id="method:hashCode()"/>   </td></tr></table></td></tr></table><table border="0" cellpadding="1" cellspacing="0" width="100%"><tr><td><h3 class="ctxid">method:toString() [NONE]</h3></td></tr><tr><td><table border="0" cellpadding="5" cellspacing="1" bgcolor="black" width="100%"><tr valign="top"><td bgcolor="#FFFFFF" colspan="1"> <a start_ctx_id="method:toString()"/> <section class="detail" id="toString()"><h3>toString</h3><div class="member-signature"> <span class="return-type"><a href="../String.html" title="class in java.lang">String</a></span> <span class="element-name">toString</span>() </div><div class="block">Returns the string representation of this layout.      </div><dl class="notes"> <dt>Overrides:</dt><dd> <code><a href="../Object.html#toString()">toString</a></code> in class <code><a href="../Object.html" title="class in java.lang">Object</a></code>  </dd> <dt>Returns:</dt><dd>the string representation of this layout     </dd>  </dl>  </section> <a end_ctx_id="method:toString()"/>   </td></tr></table></td></tr></table><table border="0" cellpadding="1" cellspacing="0" width="100%"><tr><td><h3 class="ctxid">method:paddingLayout(long) [CHANGED]</h3></td></tr><tr><td><table border="0" cellpadding="5" cellspacing="1" bgcolor="black" width="100%"><tr valign="top"><td bgcolor="#EEEEEE" colspan="2"> <a start_ctx_id="method:paddingLayout(long)"/> <section class="detail" id="paddingLayout(long)"><h3>paddingLayout</h3><div class="member-signature"> <span class="modifiers">static</span> <span class="return-type"><a href="PaddingLayout.html" title="interface in java.lang.foreign">PaddingLayout</a><sup><a href="PaddingLayout.html#preview-java.lang.foreign.PaddingLayout">PREVIEW</a></sup></span> <span class="element-name">paddingLayout</span> <wbr/> <span class="parameters">(<span class="diff-html-removed">long size</span><span class="diff-html-added">long bitSize</span>)</span>   </div><div class="block">Creates a padding layout with the given <span class="diff-html-removed">size</span><span class="diff-html-added">bitSize</span> <span class="diff-html-added">and</span> <span class="diff-html-added">a</span> <span class="diff-html-added">bit-alignment</span> <span class="diff-html-added">of</span> <span class="diff-html-added">eight</span>.            </div><dl class="notes"> <dt>Parameters:</dt><dd> <code> <code changeType="diff-removed-tag"><span class="diff-html-removed">size</span></code><span class="diff-html-added">bitSize</span> </code> - the padding size in bits.       </dd> <dt>Returns:</dt><dd>the new selector layout.   </dd> <dt>Throws:</dt><dd> <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if <code><span class="diff-html-removed">size</span><span class="diff-html-added">bitSize</span> &lt; <span class="diff-html-added">0</span>  </code> <span class="diff-html-added">or</span> <code><span class="diff-html-added">bitSize</span> <span class="diff-html-added">%</span> <span class="diff-html-added">8</span> <span class="diff-html-added">!</span>= 0<span class="diff-html-removed">.</span>    </code>      </dd>   </dl>  </section> <a end_ctx_id="method:paddingLayout(long)"/>   </td></tr><tr valign="top"><td bgcolor="#CCCCCC" colspan="1"> <a start_ctx_id="method:paddingLayout(long)"/> <section class="detail" id="paddingLayout(long)"><h3>paddingLayout</h3><div class="member-signature"> <span class="modifiers">static</span> <span class="return-type"><a href="PaddingLayout.html" title="interface in java.lang.foreign">PaddingLayout</a><sup><a href="PaddingLayout.html#preview-java.lang.foreign.PaddingLayout">PREVIEW</a></sup></span> <span class="element-name">paddingLayout</span> <wbr/> <span class="parameters">(long size)</span>   </div><div class="block">Creates a padding layout with the given size.       </div><dl class="notes"> <dt>Parameters:</dt><dd> <code changeType="diff-removed-tag">size</code> - the padding size in bits.       </dd> <dt>Returns:</dt><dd>the new selector layout.   </dd> <dt>Throws:</dt><dd> <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if <code>size &lt;= 0  </code>.    </dd>   </dl>  </section> <a end_ctx_id="method:paddingLayout(long)"/>   </td><td bgcolor="#FFFFFF" colspan="1"> <a start_ctx_id="method:paddingLayout(long)"/> <section class="detail" id="paddingLayout(long)"><h3>paddingLayout</h3><div class="member-signature"> <span class="modifiers">static</span> <span class="return-type"><a href="PaddingLayout.html" title="interface in java.lang.foreign">PaddingLayout</a><sup><a href="PaddingLayout.html#preview-java.lang.foreign.PaddingLayout">PREVIEW</a></sup></span> <span class="element-name">paddingLayout</span> <wbr/> <span class="parameters">(long bitSize)</span>   </div><div class="block">Creates a padding layout with the given bitSize and a bit-alignment of eight.            </div><dl class="notes"> <dt>Parameters:</dt><dd> <code>bitSize</code> - the padding size in bits.       </dd> <dt>Returns:</dt><dd>the new selector layout.   </dd> <dt>Throws:</dt><dd> <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if <code>bitSize &lt; 0  </code> or <code>bitSize % 8 != 0    </code>      </dd>   </dl>  </section> <a end_ctx_id="method:paddingLayout(long)"/>   </td></tr></table></td></tr></table><table border="0" cellpadding="1" cellspacing="0" width="100%"><tr><td><h3 class="ctxid">method:valueLayout(java.lang.Class,java.nio.ByteOrder) [NONE]</h3></td></tr><tr><td><table border="0" cellpadding="5" cellspacing="1" bgcolor="black" width="100%"><tr valign="top"><td bgcolor="#FFFFFF" colspan="1"> <a start_ctx_id="method:valueLayout(java.lang.Class,java.nio.ByteOrder)"/> <section class="detail" id="valueLayout(java.lang.Class,java.nio.ByteOrder)"><h3>valueLayout</h3><div class="member-signature"> <span class="modifiers">static</span> <span class="return-type"><a href="ValueLayout.html" title="interface in java.lang.foreign">ValueLayout</a><sup><a href="ValueLayout.html#preview-java.lang.foreign.ValueLayout">PREVIEW</a></sup></span> <span class="element-name">valueLayout</span> <wbr/> <span class="parameters">(<a href="../Class.html" title="class in java.lang">Class</a>&lt;?&gt; carrier, <a href="../../nio/ByteOrder.html" title="class in java.nio">ByteOrder</a> order) </span>   </div><div class="block"> Creates a value layout of given Java carrier and byte order. The type of resulting value layout is determined by the carrier provided:<ul><li> <a href="ValueLayout.OfBoolean.html" title="interface in java.lang.foreign"><code>ValueLayout.OfBoolean</code></a><sup><a href="ValueLayout.OfBoolean.html#preview-java.lang.foreign.ValueLayout.OfBoolean">PREVIEW</a></sup>, for <code>boolean.class</code>   </li><li> <a href="ValueLayout.OfByte.html" title="interface in java.lang.foreign"><code>ValueLayout.OfByte</code></a><sup><a href="ValueLayout.OfByte.html#preview-java.lang.foreign.ValueLayout.OfByte">PREVIEW</a></sup>, for <code>byte.class</code>   </li><li> <a href="ValueLayout.OfShort.html" title="interface in java.lang.foreign"><code>ValueLayout.OfShort</code></a><sup><a href="ValueLayout.OfShort.html#preview-java.lang.foreign.ValueLayout.OfShort">PREVIEW</a></sup>, for <code>short.class</code>   </li><li> <a href="ValueLayout.OfChar.html" title="interface in java.lang.foreign"><code>ValueLayout.OfChar</code></a><sup><a href="ValueLayout.OfChar.html#preview-java.lang.foreign.ValueLayout.OfChar">PREVIEW</a></sup>, for <code>char.class</code>   </li><li> <a href="ValueLayout.OfInt.html" title="interface in java.lang.foreign"><code>ValueLayout.OfInt</code></a><sup><a href="ValueLayout.OfInt.html#preview-java.lang.foreign.ValueLayout.OfInt">PREVIEW</a></sup>, for <code>int.class</code>   </li><li> <a href="ValueLayout.OfFloat.html" title="interface in java.lang.foreign"><code>ValueLayout.OfFloat</code></a><sup><a href="ValueLayout.OfFloat.html#preview-java.lang.foreign.ValueLayout.OfFloat">PREVIEW</a></sup>, for <code>float.class</code>   </li><li> <a href="ValueLayout.OfLong.html" title="interface in java.lang.foreign"><code>ValueLayout.OfLong</code></a><sup><a href="ValueLayout.OfLong.html#preview-java.lang.foreign.ValueLayout.OfLong">PREVIEW</a></sup>, for <code>long.class</code>   </li><li> <a href="ValueLayout.OfDouble.html" title="interface in java.lang.foreign"><code>ValueLayout.OfDouble</code></a><sup><a href="ValueLayout.OfDouble.html#preview-java.lang.foreign.ValueLayout.OfDouble">PREVIEW</a></sup>, for <code>double.class</code>   </li><li> <a href="ValueLayout.OfAddress.html" title="interface in java.lang.foreign"><code>ValueLayout.OfAddress</code></a><sup><a href="ValueLayout.OfAddress.html#preview-java.lang.foreign.ValueLayout.OfAddress">PREVIEW</a></sup>, for <code>MemorySegment.class</code>   </li></ul>                       </div><dl class="notes"> <dt>Parameters:</dt><dd> <code>carrier</code> - the value layout carrier.      </dd><dd> <code>order</code> - the value layout's byte order.       </dd> <dt>Returns:</dt><dd>a value layout with the given Java carrier and byte-order.         </dd> <dt>Throws:</dt><dd> <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the carrier type is not supported.         </dd>   </dl>  </section> <a end_ctx_id="method:valueLayout(java.lang.Class,java.nio.ByteOrder)"/>   </td></tr></table></td></tr></table><table border="0" cellpadding="1" cellspacing="0" width="100%"><tr><td><h3 class="ctxid">method:sequenceLayout(long,java.lang.foreign.MemoryLayout) [NONE]</h3></td></tr><tr><td><table border="0" cellpadding="5" cellspacing="1" bgcolor="black" width="100%"><tr valign="top"><td bgcolor="#FFFFFF" colspan="1"> <a start_ctx_id="method:sequenceLayout(long,java.lang.foreign.MemoryLayout)"/> <section class="detail" id="sequenceLayout(long,java.lang.foreign.MemoryLayout)"><h3>sequenceLayout</h3><div class="member-signature"> <span class="modifiers">static</span> <span class="return-type"><a href="SequenceLayout.html" title="interface in java.lang.foreign">SequenceLayout</a><sup><a href="SequenceLayout.html#preview-java.lang.foreign.SequenceLayout">PREVIEW</a></sup></span> <span class="element-name">sequenceLayout</span> <wbr/> <span class="parameters">(long elementCount, <a href="MemoryLayout.html" title="interface in java.lang.foreign">MemoryLayout</a><sup><a href="#preview-java.lang.foreign.MemoryLayout">PREVIEW</a></sup> elementLayout) </span>   </div><div class="block">Creates a sequence layout with the given element layout and element count.           </div><dl class="notes"> <dt>Parameters:</dt><dd> <code>elementCount</code> - the sequence element count.      </dd><dd> <code>elementLayout</code> - the sequence element layout.      </dd> <dt>Returns:</dt><dd>the new sequence layout with the given element layout and size.          </dd> <dt>Throws:</dt><dd> <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if <code>elementCount  </code> is negative.      </dd>   </dl>  </section> <a end_ctx_id="method:sequenceLayout(long,java.lang.foreign.MemoryLayout)"/>   </td></tr></table></td></tr></table><table border="0" cellpadding="1" cellspacing="0" width="100%"><tr><td><h3 class="ctxid">method:sequenceLayout(java.lang.foreign.MemoryLayout) [NONE]</h3></td></tr><tr><td><table border="0" cellpadding="5" cellspacing="1" bgcolor="black" width="100%"><tr valign="top"><td bgcolor="#FFFFFF" colspan="1"> <a start_ctx_id="method:sequenceLayout(java.lang.foreign.MemoryLayout)"/> <section class="detail" id="sequenceLayout(java.lang.foreign.MemoryLayout)"><h3>sequenceLayout</h3><div class="member-signature"> <span class="modifiers">static</span> <span class="return-type"><a href="SequenceLayout.html" title="interface in java.lang.foreign">SequenceLayout</a><sup><a href="SequenceLayout.html#preview-java.lang.foreign.SequenceLayout">PREVIEW</a></sup></span> <span class="element-name">sequenceLayout</span> <wbr/> <span class="parameters">(<a href="MemoryLayout.html" title="interface in java.lang.foreign">MemoryLayout</a><sup><a href="#preview-java.lang.foreign.MemoryLayout">PREVIEW</a></sup> elementLayout)</span>   </div><div class="block"> Creates a sequence layout with the given element layout and the maximum element count such that it does not overflow a <code>long</code>. This is equivalent to the following code:<div class="snippet-container"> <button class="copy snippet-copy"><span data-copied="Copied!">Copy</span><img src="../../../../copy.svg" alt="Copy"/></button><pre class="snippet">
                                                            <code class="language-java">sequenceLayout(Long.MAX_VALUE / elementLayout.bitSize(), elementLayout);
</code>
                                                        </pre> </div>                             </div><dl class="notes"> <dt>Parameters:</dt><dd> <code>elementLayout</code> - the sequence element layout.      </dd> <dt>Returns:</dt><dd>a new sequence layout with the given element layout and maximum element count.            </dd>  </dl>  </section> <a end_ctx_id="method:sequenceLayout(java.lang.foreign.MemoryLayout)"/>   </td></tr></table></td></tr></table><table border="0" cellpadding="1" cellspacing="0" width="100%"><tr><td><h3 class="ctxid">method:structLayout(java.lang.foreign.MemoryLayout...) [NONE]</h3></td></tr><tr><td><table border="0" cellpadding="5" cellspacing="1" bgcolor="black" width="100%"><tr valign="top"><td bgcolor="#FFFFFF" colspan="1"> <a start_ctx_id="method:structLayout(java.lang.foreign.MemoryLayout...)"/> <section class="detail" id="structLayout(java.lang.foreign.MemoryLayout...)"><h3>structLayout</h3><div class="member-signature"> <span class="modifiers">static</span> <span class="return-type"><a href="StructLayout.html" title="interface in java.lang.foreign">StructLayout</a><sup><a href="StructLayout.html#preview-java.lang.foreign.StructLayout">PREVIEW</a></sup></span> <span class="element-name">structLayout</span> <wbr/> <span class="parameters">(<a href="MemoryLayout.html" title="interface in java.lang.foreign">MemoryLayout</a><sup><a href="#preview-java.lang.foreign.MemoryLayout">PREVIEW</a></sup>... elements)</span>   </div><div class="block">Creates a struct layout with the given member layouts.        </div><dl class="notes"> <dt>Parameters:</dt><dd> <code>elements</code> - The member layouts of the struct layout.         </dd> <dt>Returns:</dt><dd>a struct layout with the given member layouts.       </dd> <dt>Throws:</dt><dd> <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the sum of the <a href="#bitSize()">bit sizes </a> of the member layouts overflows.             </dd>   </dl>  </section> <a end_ctx_id="method:structLayout(java.lang.foreign.MemoryLayout...)"/>   </td></tr></table></td></tr></table><table border="0" cellpadding="1" cellspacing="0" width="100%"><tr><td><h3 class="ctxid">method:unionLayout(java.lang.foreign.MemoryLayout...) [NONE]</h3></td></tr><tr><td><table border="0" cellpadding="5" cellspacing="1" bgcolor="black" width="100%"><tr valign="top"><td bgcolor="#FFFFFF" colspan="1"> <a start_ctx_id="method:unionLayout(java.lang.foreign.MemoryLayout...)"/> <section class="detail" id="unionLayout(java.lang.foreign.MemoryLayout...)"><h3>unionLayout</h3><div class="member-signature"> <span class="modifiers">static</span> <span class="return-type"><a href="UnionLayout.html" title="interface in java.lang.foreign">UnionLayout</a><sup><a href="UnionLayout.html#preview-java.lang.foreign.UnionLayout">PREVIEW</a></sup></span> <span class="element-name">unionLayout</span> <wbr/> <span class="parameters">(<a href="MemoryLayout.html" title="interface in java.lang.foreign">MemoryLayout</a><sup><a href="#preview-java.lang.foreign.MemoryLayout">PREVIEW</a></sup>... elements)</span>   </div><div class="block">Creates a union layout with the given member layouts.        </div><dl class="notes"> <dt>Parameters:</dt><dd> <code>elements</code> - The member layouts of the union layout.         </dd> <dt>Returns:</dt><dd>a union layout with the given member layouts.       </dd>  </dl>  </section>   <a end_ctx_id="method:unionLayout(java.lang.foreign.MemoryLayout...)"/>     </td></tr></table></td></tr></table></diff></diffreport>