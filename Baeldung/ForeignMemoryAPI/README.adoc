= Accessing Off-Heap Memory with the Foreign Function & Memory API

The Foreign Function & Memory (hereafter FFM) API in Java 21 provides significant improvements in working with native (off-heap) memory compared to the native `ByteBuffer` abstraction which is the predominant native memory construct.

In this tutorial, we will take a closer look at working with native memory with this API.

== Motivation

Regular Java Objects (like `String` objects) are stored on the JVM's _heap_ and are subject to garbage collection (including being moved from one physical location to another). In order to interact with native code (like C libraries), data needs to be stored in non-relocatable _off-heap_ memory (also named "native memory").

=== The ByteBuffer API

Native memory can be allocated using the `ByteBuffer::allocateDirect` method. Unfortunately, `ByteBuffer` instances obtained this way:

* Can only hold less than 2 GiB of data (indexing is based on `int` parameters).
* Cannot be deterministically freed (the garbage collector is responsible for freeing them).
* Do not prevent unintended threads from modifying its content.
* Do not have structured access (can only work with primitive values like `int`).
* Are mutable and therefore cannot be optimized very well by the C2 compiler.

=== The Unsafe API

Raw native memory regions can also be allocated using `Unsafe` providing serious drawbacks including they:

* Do not provide any spatial constraints (memory can be arbitrarily addressed).
* Do not provide any temporal guarantees (e.g. one valid memory region can point to another region that is already freed).
* Do not have structured access (can only work with primitive values like `int`)
* Memory can leak unless memory is explicitly freed.
* Do not prevent unintended threads from modifying its content.
* Provide a non-standard API that can change and/or be reduced over time.

It is not uncommon for Unsafe-based applications to crash the VM or even worse, silently modify/read arbitrary memory.

== Overview of the FFM API

The FFM API provides a safe and yet performant way of handling native memory and consists of several abstractions, some of which are:

* `Arena`
* `MemorySegment`
* `MemoryLayout`

== Arenas

An `Arena` is the main way of allocating new native memory and also provides a common lifecycle for all memory segments allocated from it. When an `Arena` is closed, said segments are atomically freed.

```
try (var arena = Arena.ofConfined()) {
    var segment = arena.allocate(16); // Allocates 16 bytes of native memory.
    // use segment ...
} // Segment is deterministically freed here
```

There are several factory methods for arenas:

* `Arena.ofConfined()` : Creates a new `Arena` that only the current thread can access.
* `Arena.ofShared()` : Creates a new `Arena` that any thread can access.
* `Arena.ofAuto()` : Creates a new `Arena` that is automatically managed by the garbage collector (same as for `ByteBuffer`).
* `Arena.global()` : Returns the one and only _global_ `Arena` that never closes and for which allocated segments live forever.

If you are used to working with ByteBuffers that are managed by the garbage collector, here is how to create a `MemorySegment` in a similar fashion:

`MemorySegment segment = Arena.ofAuto().allocate(16)`

This will allocate 16 bytes of native memory which, when not referenced anymore, is eligible for garbage collection (at some unspecified later time).

== Memory Segments

The `MemorySegment` class safely models a contiguous 64-bit memory region where spatial boundaries (start address and extent of the region), temporal bounds (the region is not freed) and thread confinements (if any) are safely enforced. Trying to violate these constraints will always result in an exception being thrown. Hence, it is not possible to crash the VM or read/write arbitrary memory locations using any access operations.

As opposed to a `ByteBuffer`, a `MemorySegment` is immutable and contains no cursors (e.g. `position()`). Instead, memory content is directly read using offsets.

It is also possible to allocate `MemorySegment` instances that model heap memory by creating a view of a backing array:

```
// Create a 400 byte segment backed by an int array with 100 elements.
MemorySegment segment = MemorySegment.ofArray(new int[100]);
```

A `MemorySegment` can also act as a view for a `ByteBuffer` or vice versa:

```
// Create a 16-byte segment backed by a ByteBuffer
MemorySegment segment = MemorySegment.ofBuffer(ByteBuffer.allocateDirect(16));

// Create a ByteBuffer backed by a segment
ByteBuffer bb = s2.asByteBuffer();
```

The underlying memory address of a segment is available via the `MemorySegment::address` function and the size of a segment is available via the `MemorySegment::byteSize` and is returned as a `long` (theoretically allowing up to 63-bit sized segments).

There are a number of get/set operations for memory segments. Here is an example where we set a long value in a segment:

```
// At byte offset 8 in the segment, sets a long value of 42L
segment.set(ValueLayout.JAVA_LONG, 8, 42L);
```

== Memory Layouts

Memory layouts provide a way to describe the contents of a memory region.

There are several built-in layout types for common Java primitive types including `ValueLayout.JAVA_INT`, `ValueLayout.JAVA_LONG`. These, together with `PaddingLayout`, can be composed into more complex forms using any of the factory methods in the `MemoryLayout` class:

* `structLayout(...)` : creates a structure of any number of other memory layouts. Elements are laid out consecutively in memory.
* `unionLayout(...)` : creates a union of any number of other memory layouts. Elements are laid out on the same location in memory.
* `sequenceLayout(...)` : creates a sequence (repetition) of a single other memory layout. Elements are laid out consecutively in memory.

For example, the layout of an array of 128 longs can be modeled like this:

```
SequenceLayout sequenceLayout = MemoryLayout.sequenceLayout(128, JAVA_LONG);
```


Here is another example with a C struct:

```
struct Point {
   int x;
   int y;
};
```

where a corresponding `MemoryLayout` can be modeled like this:

```
MemoryLayout POINT = structLayout(
    JAVA_INT.withName("x"),
    JAVA_INT.withName("y")
);
```

Provided we have statically imported `MemoryLayout.{empty}*` and `ValueLayout.{empty}*`

=== Structured Segment Access

Structured memory can be accessed using `VarHandle` instances:

```
// Accessor for x
private static final VarHandle X = POINT.varHandle(groupElement("x"));
// Accessor for y
private static final VarHandle Y = POINT.varHandle(groupElement("y"));

...

try (var arena = Arena.ofConfined()) {
    MemorySegment point = arena.allocate(POINT);
    X.set(point, 3);
    Y.set(point, 4);
    System.out.println(
            Arrays.toString(point.toArray(JAVA_INT)) // [3, 4]
    );
} // Point is deterministically freed here

```

NOTE:: `VarHandle` variables should be declared `static final` in order to enable full performance.

=== Modeling Structs

By creating a wrapper class, memory segments can be viewed as ordinary Java objects even though they might be backed by native memory:

```
    static final class Point {

        private static final MemoryLayout POINT = structLayout(
                JAVA_INT.withName("x"),
                JAVA_INT.withName("y")
        ).withName("point");

        private static final VarHandle X = POINT.varHandle(groupElement("x"));
        private static final VarHandle Y = POINT.varHandle(groupElement("y"));

        private final MemorySegment segment;

        public Point(Arena arena) {
            this.segment = arena.allocate(POINT);
        }

        public Point(Segment segment) {
            this.segment = Objects.requireNonNull(segment);
        }


        int x() {
            return (int) X.get(segment);
        }

        int y() {
            return (int) Y.get(segment);
        }

        void x(int x) {
            X.set(segment, x);
        }

        void y(int y) {
            Y.set(segment, y);
        }

        @Override
        public String toString() {
            return "Point[" + x() + ", " + y() + "]";
        }

        @Override
        public boolean equals(Object o) {
            return o instanceof Point that &&
                    this.x() == that.x() &&
                    this.x() == that.y();
        }

        @Override
        public int hashCode() {
            return Objects.hash(x(), y());
        }
    }
```


== Slicing Memory Segments

Memory segments can be sliced to provide a spatially reduced view of an arbitrary subsection of backing segments:

```
// Create a slice of a memory location representing the x-coordinate of a point segment
MemorySegment xSegment = pointSegment.slice(0, JAVA_INT);
// Create a slice of a memory location representing the y-coordinate of a point segment
MemorySegment ySegment = pointSegment.slice(4, JAVA_INT);
```

Interestingly, it is possible to create a `Stream` of slices from any memory segment using an arbitrary memory layout. For example, we could create a stream of slices of points from a memory segment that contains a sequence of points:

```
segment.elements(Point.POINT)      // Stream<MemorySegment> slices of size 16
    .map(Point::new)               // Stream<Point>
    .forEach(System.out::println);
```

This will print out all out points on the standard output.

By initially using `Arena.ofShared` when creating the memory segment with a sequence, a parallel stream can be constructed.

== Working with Memory-Mapped Files

It is also possible to map a region of a file into a mapped memory segment:

```
Set<OpenOption> sparse = Set.of(CREATE_NEW, SPARSE, READ, WRITE);

try (var fc = FileChannel.open(Path.of("sparse"), sparse)) {

    // Create a large mapped memory segment managed by the GC (Arena.auto())
     // The file can be shared across threads and/or processes
    MemorySegment mapped = fc.map(READ_WRITE, 0, 1L << 26, Arena.ofAuto());

    System.out.println(mapped);
}
```

This is useful when doing fast persistent inter-thread communication for example.

=== Preview Feature

The FFM API is a _preview feature_ in Java 21 and, in order to use it, we must use the `--enable-preview` command line argument as https://www.baeldung.com/java-preview-features[described here].

It is expected that the FFM API will be a final feature in Java 22.

=== Conclusion

In this article, we have learned the basics of the FFM API in Java 21.

Initially, we looked at some of the previous constructs like `ByteBuffer` and `Unsafe` and their limitations. Then we learned how the FFM API provides a safe and performant abstraction of both native and heap memory.

Finally, we explored some examples using the API.

== Resources

* https://openjdk.org/jeps/434[JEP 442] Foreign Function & Memory API (Third Preview)
* Run your own code on an early access JDK today by downloading a https://jdk.java.net[JDK Early-Access Build].

